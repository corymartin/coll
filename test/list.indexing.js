// Generated by CoffeeScript 1.3.3
var List, expect;

expect = require('expect.js');

List = require('../lib/coll').coll.List;

describe('List Indexing Methods', function() {
  describe('#indexOf', function() {
    var ls;
    ls = null;
    beforeEach(function() {
      return ls = List(['a', 'a', 'b', 'a']);
    });
    it('should return the index of the first item matching the passed item', function() {
      var index;
      index = ls.indexOf('a');
      expect(index).to.be(0);
      index = ls.indexOf('b');
      return expect(index).to.be(2);
    });
    it('should accept a start index as an optional second parameter', function() {
      var index;
      index = ls.indexOf('a', 0);
      expect(index).to.be(0);
      index = ls.indexOf('a', 2);
      return expect(index).to.be(3);
    });
    it('should return -1 if the start index is >= to the list length', function() {
      var index;
      index = ls.indexOf('a', 4);
      expect(index).to.be(-1);
      index = ls.indexOf('a', 99);
      return expect(index).to.be(-1);
    });
    it('should use an offset from the end of the list if the start index is negative', function() {
      var index;
      index = ls.indexOf('a', -1);
      expect(index).to.be(3);
      index = ls.indexOf('a', -3);
      return expect(index).to.be(1);
    });
    it('should search the entire list if the calculated index is less than zero', function() {
      var index;
      index = ls.indexOf('a', -7);
      expect(index).to.be(0);
      index = ls.indexOf('b', -7);
      return expect(index).to.be(2);
    });
    it('should return -1 if the item is not found', function() {
      var index;
      index = ls.indexOf('z');
      return expect(index).to.be(-1);
    });
    return it('should find a NaN value', function() {
      var index;
      ls = List([3, 'foo', NaN, /asdf/, NaN, 92]);
      index = ls.indexOf(NaN);
      return expect(index).to.be(2);
    });
  });
  describe('#lastIndexOf', function() {
    var ls;
    ls = null;
    beforeEach(function() {
      return ls = List(['a', 'a', 'b', 'a']);
    });
    it('should return the index of the last item in the list matching the passed item', function() {
      var index;
      index = ls.lastIndexOf('a');
      expect(index).to.be(3);
      index = ls.lastIndexOf('b');
      return expect(index).to.be(2);
    });
    it('should accept an index to search backwards from as an optional second parameter', function() {
      var index;
      index = ls.lastIndexOf('a', 2);
      expect(index).to.be(1);
      index = ls.lastIndexOf('a', 3);
      expect(index).to.be(3);
      index = ls.lastIndexOf('a', 0);
      return expect(index).to.be(0);
    });
    it('should search the entire list if the index is >= to the list length', function() {
      var index;
      index = ls.lastIndexOf('a', 4);
      expect(index).to.be(3);
      index = ls.lastIndexOf('a', 99);
      return expect(index).to.be(3);
    });
    it('should use an offset from the end of the list if the index is negative', function() {
      var index;
      index = ls.lastIndexOf('a', -1);
      expect(index).to.be(3);
      index = ls.lastIndexOf('a', -2);
      return expect(index).to.be(1);
    });
    it('should return -1 if the calculated index is less than zero', function() {
      var index;
      index = ls.lastIndexOf('a', -99);
      expect(index).to.be(-1);
      index = ls.lastIndexOf('b', -99);
      return expect(index).to.be(-1);
    });
    it('should return -1 if the item is not found', function() {
      var index;
      index = ls.lastIndexOf('z');
      return expect(index).to.be(-1);
    });
    return it('should find a NaN value', function() {
      var index;
      ls = List([3, 'foo', NaN, /asdf/, NaN, 92]);
      index = ls.lastIndexOf(NaN);
      return expect(index).to.be(4);
    });
  });
  describe('#indicesOf', function() {
    var l1, l2;
    l1 = l2 = null;
    beforeEach(function() {
      l1 = List('aabab');
      return l2 = List(['a', 5, 5, 0, 5, false, 'fish', 5, 5, 'bar']);
    });
    it('should return a list of all indexes matching the passed item', function() {
      var indexes;
      indexes = l1.indicesOf('a');
      expect(indexes).to.be.a(List);
      expect(indexes.length).to.be(3);
      expect(indexes[0]).to.be(0);
      expect(indexes[1]).to.be(1);
      expect(indexes[2]).to.be(3);
      indexes = l2.indicesOf(5);
      expect(indexes.length).to.be(5);
      expect(indexes[0]).to.be(1);
      expect(indexes[1]).to.be(2);
      expect(indexes[2]).to.be(4);
      expect(indexes[3]).to.be(7);
      return expect(indexes[4]).to.be(8);
    });
    it('should accept a start index as an optional second parameter', function() {
      var indexes;
      indexes = l1.indicesOf('a', 0);
      expect(indexes.length).to.be(3);
      indexes = l1.indicesOf('a', 1);
      expect(indexes.length).to.be(2);
      indexes = l1.indicesOf('a', 2);
      return expect(indexes.length).to.be(1);
    });
    it('should return an empty list if the start index is >= to the list length', function() {
      var indexes;
      indexes = l1.indicesOf('a', 5);
      expect(indexes.length).to.be(0);
      indexes = l1.indicesOf('a', 99);
      return expect(indexes.length).to.be(0);
    });
    it('should use an offset from the end of the list if the index is negative', function() {
      var indexes;
      indexes = l1.indicesOf('a', -3);
      expect(indexes.length).to.be(1);
      indexes = l1.indicesOf('a', -4);
      return expect(indexes.length).to.be(2);
    });
    it('should search the entire list if the calculated index is less than zero', function() {
      var indexes;
      indexes = l1.indicesOf('a', -7);
      return expect(indexes.length).to.be(3);
    });
    return it('should return an empty list if no occurences of the item is found', function() {
      var indexes;
      indexes = l1.indicesOf('z');
      expect(indexes).to.be.a(List);
      return expect(indexes.length).to.be(0);
    });
  });
  describe('#indexIf', function() {
    var ls;
    ls = null;
    beforeEach(function() {
      return ls = List([1, 5, 9, 14, 17]);
    });
    it('should return the index of the first item passing the callback test', function() {
      var index;
      index = ls.indexIf(function(val) {
        return val % 2 === 0;
      });
      expect(index).to.be(3);
      index = ls.indexIf(function(val) {
        return val % 5 === 0;
      });
      return expect(index).to.be(1);
    });
    it('should throw an error if the callback is not passed', function() {
      expect(function() {
        return ls.indexIf();
      }).to.throwError();
      return expect(function() {
        return ls.indexIf('foo');
      }).to.throwError();
    });
    it('should accept a starting index as an optional second parameter', function() {
      var index;
      index = ls.indexIf(0, function(val) {
        return val % 2 === 0;
      });
      expect(index).to.be(3);
      index = ls.indexIf(1, function(val) {
        return val % 2 !== 0;
      });
      expect(index).to.be(1);
      index = ls.indexIf(3, function(val) {
        return val % 2 !== 0;
      });
      return expect(index).to.be(4);
    });
    it('should return -1 if the start index is >= to the list length', function() {
      var index;
      index = ls.indexIf(5, function(val) {
        return val === 17;
      });
      expect(index).to.be(-1);
      index = ls.indexIf(99, function(val) {
        return val === 17;
      });
      return expect(index).to.be(-1);
    });
    it('should use an offset from the end of the list if the start index is negative', function() {
      var index;
      index = ls.indexIf(-1, function(val) {
        return val % 2 !== 0;
      });
      expect(index).to.be(4);
      index = ls.indexIf(-3, function(val) {
        return val % 2 !== 0;
      });
      return expect(index).to.be(2);
    });
    it('should search the entire list if the calculated index is less than zero', function() {
      var index;
      index = ls.indexIf(-99, function(val) {
        return val % 2 !== 0;
      });
      expect(index).to.be(0);
      index = ls.indexIf(-99, function(val) {
        return val % 2 === 0;
      });
      return expect(index).to.be(3);
    });
    it('should accept a context object for the callback as an optional third parameter', function() {
      var index, obj;
      obj = {
        foo: 'bar'
      };
      return index = ls.indexIf(null, obj, function(val) {
        expect(this).to.be(obj);
        expect(this.foo).to.be('bar');
        return false;
      });
    });
    it('should return -1 if the item is not found', function() {
      var index;
      index = ls.indexIf(function(val) {
        return val === 999;
      });
      return expect(index).to.be(-1);
    });
    return it('should pass 3 parameters to the callback test: current value, index, the list', function() {
      ls = List(['foo']);
      return ls.indexIf(function(val, index, list) {
        expect(val).to.be('foo');
        expect(index).to.be(0);
        return expect(list).to.be(ls);
      });
    });
  });
  describe('#lastIndexIf', function() {
    var ls;
    ls = null;
    beforeEach(function() {
      return ls = List(['a', 'a', 'b', 'a']);
    });
    it('should return the index of the last item passing the callback test', function() {
      var index;
      index = ls.lastIndexIf(function(val) {
        return val === 'a';
      });
      expect(index).to.be(3);
      index = ls.lastIndexIf(function(val) {
        return val === 'b';
      });
      return expect(index).to.be(2);
    });
    it('should throw an error if the callback is not passed', function() {
      expect(function() {
        return ls.lastIndexIf();
      }).to.throwError();
      return expect(function() {
        return ls.lastIndexIf('foo');
      }).to.throwError();
    });
    it('should accept an index to search backwards from as an optional second parameter', function() {
      var index;
      index = ls.lastIndexIf(2, function(val) {
        return val === 'a';
      });
      expect(index).to.be(1);
      index = ls.lastIndexIf(3, function(val) {
        return val === 'a';
      });
      expect(index).to.be(3);
      index = ls.lastIndexIf(0, function(val) {
        return val === 'a';
      });
      return expect(index).to.be(0);
    });
    it('should search the entire list if the index is >= to the list length', function() {
      var index;
      index = ls.lastIndexIf(4, function(val) {
        return val === 'a';
      });
      expect(index).to.be(3);
      index = ls.lastIndexIf(99, function(val) {
        return val === 'a';
      });
      return expect(index).to.be(3);
    });
    it('should use an offset from the end of the list if the index is negative', function() {
      var index;
      index = ls.lastIndexIf(-1, function(val) {
        return val === 'a';
      });
      expect(index).to.be(3);
      index = ls.lastIndexIf(-2, function(val) {
        return val === 'a';
      });
      return expect(index).to.be(1);
    });
    it('should return -1 if the calculated index is less than zero', function() {
      var index;
      index = ls.lastIndexIf(-99, function(val) {
        return val === 'a';
      });
      return expect(index).to.be(-1);
    });
    it('should accept a context object for the callback as an optional third parameter', function() {
      var index, obj;
      obj = {
        foo: 'bar'
      };
      return index = ls.lastIndexIf(null, obj, function(val) {
        expect(this).to.be(obj);
        expect(this.foo).to.be('bar');
        return false;
      });
    });
    it('should return -1 if the item is not found', function() {
      var index;
      index = ls.lastIndexIf(function(val) {
        return val === 'z';
      });
      return expect(index).to.be(-1);
    });
    return it('should pass 3 parameters to the callback test: current value, index, the list', function() {
      ls = List(['foo']);
      return ls.lastIndexIf(function(val, index, list) {
        expect(val).to.be('foo');
        expect(index).to.be(0);
        return expect(list).to.be(ls);
      });
    });
  });
  return describe('#indicesIf', function() {
    var l1, l2;
    l1 = l2 = null;
    beforeEach(function() {
      l1 = List('aabab');
      return l2 = List(['a', NaN, null, 0, 5, 'fish', void 0, NaN, 'bar']);
    });
    it('should return a list of all indexes matching the passed item', function() {
      var indexes;
      indexes = l1.indicesIf(function(v) {
        return v === 'a';
      });
      expect(indexes).to.be.a(List);
      expect(indexes.length).to.be(3);
      expect(indexes[0]).to.be(0);
      expect(indexes[1]).to.be(1);
      expect(indexes[2]).to.be(3);
      indexes = l2.indicesIf(function(v) {
        return !v;
      });
      expect(indexes.length).to.be(5);
      expect(indexes[0]).to.be(1);
      expect(indexes[1]).to.be(2);
      expect(indexes[2]).to.be(3);
      expect(indexes[3]).to.be(6);
      return expect(indexes[4]).to.be(7);
    });
    it('should accept a start index as an optional second parameter', function() {
      var indexes;
      indexes = l1.indicesIf(0, function(v) {
        return v === 'a';
      });
      expect(indexes.length).to.be(3);
      indexes = l1.indicesIf(1, function(v) {
        return v === 'a';
      });
      expect(indexes.length).to.be(2);
      indexes = l1.indicesIf(2, function(v) {
        return v === 'a';
      });
      return expect(indexes.length).to.be(1);
    });
    it('should return an empty list if the start index is >= to the list length', function() {
      var indexes;
      indexes = l1.indicesIf(5, function(v) {
        return v === 'a';
      });
      expect(indexes.length).to.be(0);
      indexes = l1.indicesIf(99, function(v) {
        return v === 'a';
      });
      return expect(indexes.length).to.be(0);
    });
    it('should use an offset from the end of the list if the index is negative', function() {
      var indexes;
      indexes = l1.indicesIf(-3, function(v) {
        return v === 'a';
      });
      expect(indexes.length).to.be(1);
      indexes = l1.indicesIf(-4, function(v) {
        return v === 'a';
      });
      return expect(indexes.length).to.be(2);
    });
    it('should search the entire list if the calculated index is less than zero', function() {
      var indexes;
      indexes = l1.indicesIf(-7, function(v) {
        return v === 'a';
      });
      return expect(indexes.length).to.be(3);
    });
    it('should return an empty list if no occurences of the item is found', function() {
      var indexes;
      indexes = l1.indicesIf(function(v) {
        return v === 'z';
      });
      expect(indexes).to.be.a(List);
      return expect(indexes.length).to.be(0);
    });
    it('should accept a context object for the callback as an optional third parameter', function() {
      var obj;
      l1 = List('a');
      obj = {
        foo: 'bar'
      };
      return l1.indicesIf(null, obj, function(v) {
        expect(this).to.be(obj);
        expect(this.foo).to.be('bar');
        return true;
      });
    });
    return it('should pass 3 parameters to the callback test: current value, index, the list', function() {
      l1 = List(['foo']);
      return l1.indicesIf(function(val, index, list) {
        expect(val).to.be('foo');
        expect(index).to.be(0);
        return expect(list).to.be(l1);
      });
    });
  });
});
