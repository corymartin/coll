// Generated by CoffeeScript 1.3.3
var List, expect;

expect = require('expect.js');

List = require('../lib/coll').List;

describe('List Indexing Methods', function() {
  describe('#indexOf', function() {
    var ls;
    ls = null;
    beforeEach(function() {
      return ls = List(['a', 'a', 'b', 'a']);
    });
    it('should return the index of the first item matching the passed item', function() {
      var index;
      index = ls.indexOf('a');
      expect(index).to.be(0);
      index = ls.indexOf('b');
      return expect(index).to.be(2);
    });
    it('should accept a start index as an optional second parameter', function() {
      var index;
      index = ls.indexOf('a', 0);
      expect(index).to.be(0);
      index = ls.indexOf('a', 2);
      return expect(index).to.be(3);
    });
    it('should return -1 if the start index is >= to the list length', function() {
      var index;
      index = ls.indexOf('a', 4);
      expect(index).to.be(-1);
      index = ls.indexOf('a', 99);
      return expect(index).to.be(-1);
    });
    it('should use an offset from the end of the list if the start index is negative', function() {
      var index;
      index = ls.indexOf('a', -1);
      expect(index).to.be(3);
      index = ls.indexOf('a', -3);
      return expect(index).to.be(1);
    });
    it('should search the entire list if the calculated index is less than zero', function() {
      var index;
      index = ls.indexOf('a', -7);
      expect(index).to.be(0);
      index = ls.indexOf('b', -7);
      return expect(index).to.be(2);
    });
    return it('should return -1 if the item is not found', function() {
      var index;
      index = ls.indexOf('z');
      return expect(index).to.be(-1);
    });
  });
  describe('#lastIndexOf', function() {
    var ls;
    ls = null;
    beforeEach(function() {
      return ls = List(['a', 'a', 'b', 'a']);
    });
    it('should return the index of the last item in the list matching the passed item', function() {
      var index;
      index = ls.lastIndexOf('a');
      expect(index).to.be(3);
      index = ls.lastIndexOf('b');
      return expect(index).to.be(2);
    });
    it('should accept an index to search backwards from as an optional second parameter', function() {
      var index;
      index = ls.lastIndexOf('a', 2);
      expect(index).to.be(1);
      index = ls.lastIndexOf('a', 3);
      expect(index).to.be(3);
      index = ls.lastIndexOf('a', 0);
      return expect(index).to.be(0);
    });
    it('should search the entire list if the index is >= to the list length', function() {
      var index;
      index = ls.lastIndexOf('a', 4);
      expect(index).to.be(3);
      index = ls.lastIndexOf('a', 99);
      return expect(index).to.be(3);
    });
    it('should use an offset from the end of the list if the index is negative', function() {
      var index;
      index = ls.lastIndexOf('a', -1);
      expect(index).to.be(3);
      index = ls.lastIndexOf('a', -2);
      return expect(index).to.be(1);
    });
    it('should return -1 if the calculated index is less than zero', function() {
      var index;
      index = ls.lastIndexOf('a', -99);
      expect(index).to.be(-1);
      index = ls.lastIndexOf('b', -99);
      return expect(index).to.be(-1);
    });
    return it('should return -1 if the item is not found', function() {
      var index;
      index = ls.lastIndexOf('z');
      return expect(index).to.be(-1);
    });
  });
  describe('#indicesOf', function() {
    var ls;
    ls = null;
    beforeEach(function() {
      return ls = List('aabab');
    });
    it('should return an array of all indexes matching the passed item', function() {
      var indexes;
      indexes = ls.indicesOf('a');
      expect(indexes).to.be.an(Array);
      expect(indexes.length).to.be(3);
      expect(indexes[0]).to.be(0);
      expect(indexes[1]).to.be(1);
      return expect(indexes[2]).to.be(3);
    });
    it('should accept a start index as an optional second parameter', function() {
      var indexes;
      indexes = ls.indicesOf('a', 0);
      expect(indexes.length).to.be(3);
      indexes = ls.indicesOf('a', 1);
      expect(indexes.length).to.be(2);
      indexes = ls.indicesOf('a', 2);
      return expect(indexes.length).to.be(1);
    });
    it('should return an empty array if the start index is >= to the list length', function() {
      var indexes;
      indexes = ls.indicesOf('a', 5);
      expect(indexes.length).to.be(0);
      indexes = ls.indicesOf('a', 99);
      return expect(indexes.length).to.be(0);
    });
    it('should use an offset from the end of the list if the index is negative', function() {
      var indexes;
      indexes = ls.indicesOf('a', -3);
      expect(indexes.length).to.be(1);
      indexes = ls.indicesOf('a', -4);
      return expect(indexes.length).to.be(2);
    });
    it('should search the entire list if the calculated index is less than zero', function() {
      var indexes;
      indexes = ls.indicesOf('a', -7);
      return expect(indexes.length).to.be(3);
    });
    return it('should return an empty array if no occurences of the item is found', function() {
      var indexes;
      indexes = ls.indicesOf('z');
      expect(indexes).to.be.an(Array);
      return expect(indexes.length).to.be(0);
    });
  });
  describe('#indexIf', function() {
    var ls;
    ls = null;
    beforeEach(function() {
      return ls = List([1, 5, 9, 14, 17]);
    });
    it('should return the index of the first item passing the callback test', function() {
      var index;
      index = ls.indexIf(function(val) {
        return val % 2 === 0;
      });
      expect(index).to.be(3);
      index = ls.indexIf(function(val) {
        return val % 5 === 0;
      });
      return expect(index).to.be(1);
    });
    it('should throw an error if the callback is not passed', function() {
      expect(function() {
        return ls.indexIf();
      }).to.throwError();
      return expect(function() {
        return ls.indexIf('foo');
      }).to.throwError();
    });
    it('should accept a starting index as an optional second parameter', function() {
      var index;
      index = ls.indexIf((function(val) {
        return val % 2 === 0;
      }), 0);
      expect(index).to.be(3);
      index = ls.indexIf((function(val) {
        return val % 2 !== 0;
      }), 1);
      expect(index).to.be(1);
      index = ls.indexIf((function(val) {
        return val % 2 !== 0;
      }), 3);
      return expect(index).to.be(4);
    });
    it('should return -1 if the start index is >= to the list length', function() {
      var index;
      index = ls.indexIf((function(val) {
        return val === 17;
      }), 5);
      expect(index).to.be(-1);
      index = ls.indexIf((function(val) {
        return val === 17;
      }), 99);
      return expect(index).to.be(-1);
    });
    it('should use an offset from the end of the list if the start index is negative', function() {
      var index;
      index = ls.indexIf((function(val) {
        return val % 2 !== 0;
      }), -1);
      expect(index).to.be(4);
      index = ls.indexIf((function(val) {
        return val % 2 !== 0;
      }), -3);
      return expect(index).to.be(2);
    });
    it('should search the entire list if the calculated index is less than zero', function() {
      var index;
      index = ls.indexIf((function(val) {
        return val % 2 !== 0;
      }), -99);
      expect(index).to.be(0);
      index = ls.indexIf((function(val) {
        return val % 2 === 0;
      }), -99);
      return expect(index).to.be(3);
    });
    it('should accept a context object for the callback as an optional third parameter', function() {
      var index, obj;
      obj = {
        foo: 'bar'
      };
      return index = ls.indexIf((function(val) {
        expect(this).to.be(obj);
        expect(this.foo).to.be('bar');
        return false;
      }), 0, obj);
    });
    it('should return -1 if the item is not found', function() {
      var index;
      index = ls.indexIf(function(val) {
        return val === 999;
      });
      return expect(index).to.be(-1);
    });
    return it('should pass 3 parameters to the callback test: current value, index, the list', function() {
      ls = List(['foo']);
      return ls.indexIf(function(val, index, list) {
        expect(val).to.be('foo');
        expect(index).to.be(0);
        return expect(list).to.be(ls);
      });
    });
  });
  describe('#lastIndexIf', function() {
    var ls;
    ls = null;
    beforeEach(function() {
      return ls = List(['a', 'a', 'b', 'a']);
    });
    it('should return the index of the last item passing the callback test', function() {
      var index;
      index = ls.lastIndexIf(function(val) {
        return val === 'a';
      });
      expect(index).to.be(3);
      index = ls.lastIndexIf(function(val) {
        return val === 'b';
      });
      return expect(index).to.be(2);
    });
    it('should throw an error if the callback is not passed', function() {
      expect(function() {
        return ls.lastIndexIf();
      }).to.throwError();
      return expect(function() {
        return ls.lastIndexIf('foo');
      }).to.throwError();
    });
    it('should accept an index to search backwards from as an optional second parameter', function() {
      var index;
      index = ls.lastIndexIf((function(val) {
        return val === 'a';
      }), 2);
      expect(index).to.be(1);
      index = ls.lastIndexIf((function(val) {
        return val === 'a';
      }), 3);
      expect(index).to.be(3);
      index = ls.lastIndexIf((function(val) {
        return val === 'a';
      }), 0);
      return expect(index).to.be(0);
    });
    it('should search the entire list if the index is >= to the list length', function() {
      var index;
      index = ls.lastIndexIf((function(val) {
        return val === 'a';
      }), 4);
      expect(index).to.be(3);
      index = ls.lastIndexIf((function(val) {
        return val === 'a';
      }), 99);
      return expect(index).to.be(3);
    });
    it('should use an offset from the end of the list if the index is negative', function() {
      var index;
      index = ls.lastIndexIf((function(val) {
        return val === 'a';
      }), -1);
      expect(index).to.be(3);
      index = ls.lastIndexIf((function(val) {
        return val === 'a';
      }), -2);
      return expect(index).to.be(1);
    });
    it('should return -1 if the calculated index is less than zero', function() {
      var index;
      index = ls.lastIndexIf((function(val) {
        return val === 'a';
      }), -99);
      expect(index).to.be(-1);
      index = ls.lastIndexIf((function(val) {
        return val === 'b';
      }), -99);
      return expect(index).to.be(-1);
    });
    it('should accept a context object for the callback as an optional third parameter', function() {
      var index, obj;
      obj = {
        foo: 'bar'
      };
      return index = ls.lastIndexIf((function(val) {
        expect(this).to.be(obj);
        expect(this.foo).to.be('bar');
        return false;
      }), 0, obj);
    });
    it('should return -1 if the item is not found', function() {
      var index;
      index = ls.lastIndexIf(function(val) {
        return val === 'z';
      });
      return expect(index).to.be(-1);
    });
    return it('should pass 3 parameters to the callback test: current value, index, the list', function() {
      ls = List(['foo']);
      return ls.lastIndexIf(function(val, index, list) {
        expect(val).to.be('foo');
        expect(index).to.be(0);
        return expect(list).to.be(ls);
      });
    });
  });
  return describe('#indicesIf', function() {
    var ls;
    ls = null;
    beforeEach(function() {
      return ls = List('aabab');
    });
    it('should return an array of all indexes matching the passed item', function() {
      var indexes;
      indexes = ls.indicesIf(function(v) {
        return v === 'a';
      });
      expect(indexes).to.be.an(Array);
      expect(indexes.length).to.be(3);
      expect(indexes[0]).to.be(0);
      expect(indexes[1]).to.be(1);
      return expect(indexes[2]).to.be(3);
    });
    it('should accept a start index as an optional second parameter', function() {
      var indexes;
      indexes = ls.indicesIf((function(v) {
        return v === 'a';
      }), 0);
      expect(indexes.length).to.be(3);
      indexes = ls.indicesIf((function(v) {
        return v === 'a';
      }), 1);
      expect(indexes.length).to.be(2);
      indexes = ls.indicesIf((function(v) {
        return v === 'a';
      }), 2);
      return expect(indexes.length).to.be(1);
    });
    it('should return an empty array if the start index is >= to the list length', function() {
      var indexes;
      indexes = ls.indicesIf((function(v) {
        return v === 'a';
      }), 5);
      expect(indexes.length).to.be(0);
      indexes = ls.indicesIf((function(v) {
        return v === 'a';
      }), 99);
      return expect(indexes.length).to.be(0);
    });
    it('should use an offset from the end of the list if the index is negative', function() {
      var indexes;
      indexes = ls.indicesIf((function(v) {
        return v === 'a';
      }), -3);
      expect(indexes.length).to.be(1);
      indexes = ls.indicesIf((function(v) {
        return v === 'a';
      }), -4);
      return expect(indexes.length).to.be(2);
    });
    it('should search the entire list if the calculated index is less than zero', function() {
      var indexes;
      indexes = ls.indicesIf((function(v) {
        return v === 'a';
      }), -7);
      return expect(indexes.length).to.be(3);
    });
    it('should return an empty array if no occurences of the item is found', function() {
      var indexes;
      indexes = ls.indicesIf(function(v) {
        return v === 'z';
      });
      expect(indexes).to.be.an(Array);
      return expect(indexes.length).to.be(0);
    });
    it('should accept a context object for the callback as an optional third parameter', function() {
      var obj;
      ls = List('a');
      obj = {
        foo: 'bar'
      };
      return ls.indicesIf((function(v) {
        expect(this).to.be(obj);
        expect(this.foo).to.be('bar');
        return true;
      }), 0, obj);
    });
    return it('should pass 3 parameters to the callback test: current value, index, the list', function() {
      ls = List(['foo']);
      return ls.indicesIf(function(val, index, list) {
        expect(val).to.be('foo');
        expect(index).to.be(0);
        return expect(list).to.be(ls);
      });
    });
  });
});
