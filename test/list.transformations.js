// Generated by CoffeeScript 1.3.3
var List, TypedList, expect, _ref;

expect = require('expect.js');

_ref = require('../lib/coll'), TypedList = _ref.TypedList, List = _ref.List;

describe('TypedList / List Transformation Methods', function() {
  describe('#filter', function() {
    var l1;
    l1 = null;
    beforeEach(function() {
      return l1 = TypedList('Number', [1, 2, 3, 4]);
    });
    it('should return a new list containing only the elements that pass the iterator test', function() {
      var evens;
      evens = l1.filter(function(v) {
        return v % 2 === 0;
      });
      expect(evens.length).to.be(2);
      expect(evens[0]).to.be(2);
      return expect(evens[1]).to.be(4);
    });
    it('should not modify the instance list', function() {
      l1.filter(function(v) {
        return v % 2 === 0;
      });
      expect(l1.length).to.be(4);
      expect(l1[0]).to.be(1);
      return expect(l1[1]).to.be(2);
    });
    it('should accept a context object for the callback as an optional second parameter', function() {
      var obj;
      obj = {
        foo: 'bar'
      };
      return l1.filter((function(v) {
        expect(this).to.be(obj);
        expect(this.foo).to.be('bar');
        return true;
      }), obj);
    });
    return it('should pass 3 parameters to the callback test: current value, index, the list', function() {
      var ls;
      ls = TypedList('String', ['foo']);
      return ls.filter(function(val, index, list) {
        expect(val).to.be('foo');
        expect(index).to.be(0);
        return expect(list).to.be(ls);
      });
    });
  });
  describe('#reject', function() {
    var l1;
    l1 = null;
    beforeEach(function() {
      return l1 = TypedList('Number', [1, 2, 3, 4]);
    });
    it('should return a new list containing only the elements that fail the iterator test', function() {
      var evens;
      evens = l1.reject(function(v) {
        return v % 2 === 0;
      });
      expect(evens.length).to.be(2);
      expect(evens[0]).to.be(1);
      return expect(evens[1]).to.be(3);
    });
    it('should not modify the instance list', function() {
      l1.reject(function(v) {
        return v % 2 === 0;
      });
      expect(l1.length).to.be(4);
      expect(l1[0]).to.be(1);
      return expect(l1[1]).to.be(2);
    });
    it('should accept a context object for the callback as an\noptional second parameter', function() {
      var obj;
      obj = {
        foo: 'bar'
      };
      return l1.reject((function(v) {
        expect(this).to.be(obj);
        expect(this.foo).to.be('bar');
        return true;
      }), obj);
    });
    return it('should pass 3 parameters to the callback test:\ncurrent value, index, the list', function() {
      var ls;
      ls = TypedList('String', ['foo']);
      return ls.reject(function(val, index, list) {
        expect(val).to.be('foo');
        expect(index).to.be(0);
        return expect(list).to.be(ls);
      });
    });
  });
  describe('#map', function() {
    var l1;
    l1 = null;
    beforeEach(function() {
      return l1 = TypedList('Number', [1, 2, 3, 4]);
    });
    it('should return a new list composed of the results returned\nby the iterator', function() {
      var x;
      x = l1.map(function(v) {
        return v * 10;
      });
      expect(x[0]).to.be(10);
      expect(x[1]).to.be(20);
      expect(x[2]).to.be(30);
      return expect(x[3]).to.be(40);
    });
    it('should not modify the instance list', function() {
      var x;
      x = l1.map(function(v) {
        return v * 10;
      });
      expect(l1[0]).to.be(1);
      expect(l1[1]).to.be(2);
      expect(l1[2]).to.be(3);
      return expect(l1[3]).to.be(4);
    });
    it('should return a list with the same type as the instance list', function() {
      var x;
      x = l1.map(function(v) {
        return v * 10;
      });
      return expect(x.type).to.be('Number');
    });
    it('should return a list of a new type if the optional type\nparameter is used (TypedList only)', function() {
      var l, x;
      x = l1.map((function(v) {
        return "_" + v + "_";
      }), null, 'String');
      expect(x.type).to.be('String');
      l = List([1, 2, 3, 4]);
      x = l.map((function(v) {
        return v;
      }), null, 'String');
      return expect(x.type).to.be('Any');
    });
    it('should accept a context object for the callback as an optional second parameter', function() {
      var obj;
      obj = {
        foo: 'bar'
      };
      return l1.map((function(v) {
        expect(this).to.be(obj);
        expect(this.foo).to.be('bar');
        return v;
      }), obj);
    });
    return it('should pass 3 parameters to the callback test: current value, index, the list', function() {
      var ls;
      ls = TypedList('String', ['foo']);
      return ls.map(function(val, index, list) {
        expect(val).to.be('foo');
        expect(index).to.be(0);
        expect(list).to.be(ls);
        return val;
      });
    });
  });
  return describe('#intersperse', function() {
    var l1, l2;
    l1 = l2 = null;
    beforeEach(function() {
      l1 = TypedList('Number', [1, 2, 3]);
      return l2 = List(['a', new Date, [1, 2], true]);
    });
    it('should return a new list with the passed item inserted between\nevery item in the original list', function() {
      var regex, x;
      x = l1.intersperse(0);
      expect(x).to.be.a(TypedList);
      expect(x.length).to.be(5);
      expect(x[0]).to.be(1);
      expect(x[1]).to.be(0);
      expect(x[2]).to.be(2);
      expect(x[3]).to.be(0);
      expect(x[4]).to.be(3);
      regex = /foo/;
      x = l2.intersperse(regex);
      expect(x).to.be.a(List);
      expect(x.length).to.be(7);
      expect(x[0]).to.be('a');
      expect(x[1]).to.be(regex);
      expect(x[2]).to.be.a(Date);
      expect(x[3]).to.be(regex);
      expect(x[4]).to.eql([1, 2]);
      expect(x[5]).to.be(regex);
      return expect(x[6]).to.be(true);
    });
    return it('should not modify the instance list', function() {
      l1.intersperse(0);
      l2.intersperse('-');
      expect(l1.length).to.be(3);
      return expect(l2.length).to.be(4);
    });
  });
});
