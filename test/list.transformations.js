// Generated by CoffeeScript 1.3.1
(function() {
  var List, TypedList, expect, _ref;

  expect = require('expect.js');

  _ref = require('../lib/coll'), TypedList = _ref.TypedList, List = _ref.List;

  describe('TypedList / List Transformation Methods', function() {
    describe('#filter', function() {
      var l1;
      l1 = null;
      beforeEach(function() {
        return l1 = TypedList('Number', [1, 2, 3, 4]);
      });
      it('should return a new list containing only the elements that pass the iterator test', function() {
        var evens;
        evens = l1.filter(function(v) {
          return v % 2 === 0;
        });
        expect(evens.length).to.be(2);
        expect(evens[0]).to.be(2);
        return expect(evens[1]).to.be(4);
      });
      it('should not modify the instance list', function() {
        l1.filter(function(v) {
          return v % 2 === 0;
        });
        expect(l1.length).to.be(4);
        expect(l1[0]).to.be(1);
        return expect(l1[1]).to.be(2);
      });
      it('should accept a context object for the callback as an optional second parameter', function() {
        var obj;
        obj = {
          foo: 'bar'
        };
        return l1.filter((function(v) {
          expect(this).to.be(obj);
          expect(this.foo).to.be('bar');
          return true;
        }), obj);
      });
      return it('should pass 3 parameters to the callback test: current value, index, the list', function() {
        var ls;
        ls = TypedList('String', ['foo']);
        return ls.filter(function(val, index, list) {
          expect(val).to.be('foo');
          expect(index).to.be(0);
          return expect(list).to.be(ls);
        });
      });
    });
    describe('#reject', function() {
      var l1;
      l1 = null;
      beforeEach(function() {
        return l1 = TypedList('Number', [1, 2, 3, 4]);
      });
      it('should return a new list containing only the elements that fail the iterator test', function() {
        var evens;
        evens = l1.reject(function(v) {
          return v % 2 === 0;
        });
        expect(evens.length).to.be(2);
        expect(evens[0]).to.be(1);
        return expect(evens[1]).to.be(3);
      });
      it('should not modify the instance list', function() {
        l1.reject(function(v) {
          return v % 2 === 0;
        });
        expect(l1.length).to.be(4);
        expect(l1[0]).to.be(1);
        return expect(l1[1]).to.be(2);
      });
      it('should accept a context object for the callback as an optional second parameter', function() {
        var obj;
        obj = {
          foo: 'bar'
        };
        return l1.reject((function(v) {
          expect(this).to.be(obj);
          expect(this.foo).to.be('bar');
          return true;
        }), obj);
      });
      return it('should pass 3 parameters to the callback test: current value, index, the list', function() {
        var ls;
        ls = TypedList('String', ['foo']);
        return ls.reject(function(val, index, list) {
          expect(val).to.be('foo');
          expect(index).to.be(0);
          return expect(list).to.be(ls);
        });
      });
    });
    return describe('#map', function() {
      var l1;
      l1 = null;
      beforeEach(function() {
        return l1 = TypedList('Number', [1, 2, 3, 4]);
      });
      it('should return a new list composed of the results returned by the iterator', function() {
        var x;
        x = l1.map(function(v) {
          return v * 10;
        });
        expect(x[0]).to.be(10);
        expect(x[1]).to.be(20);
        expect(x[2]).to.be(30);
        return expect(x[3]).to.be(40);
      });
      it('should not modify the instance list', function() {
        var x;
        x = l1.map(function(v) {
          return v * 10;
        });
        expect(l1[0]).to.be(1);
        expect(l1[1]).to.be(2);
        expect(l1[2]).to.be(3);
        return expect(l1[3]).to.be(4);
      });
      it('should return a list with the same type as the instance list', function() {
        var x;
        x = l1.map(function(v) {
          return v * 10;
        });
        return expect(x.type).to.be('Number');
      });
      it('should return a list of a new type if the optional type paramater is used (TypedList only)', function() {
        var l, x;
        x = l1.map((function(v) {
          return "_" + v + "_";
        }), null, 'String');
        expect(x.type).to.be('String');
        l = List([1, 2, 3, 4]);
        x = l.map((function(v) {
          return v;
        }), null, 'String');
        return expect(x.type).to.be('Any');
      });
      it('should accept a context object for the callback as an optional second parameter', function() {
        var obj;
        obj = {
          foo: 'bar'
        };
        return l1.map((function(v) {
          expect(this).to.be(obj);
          expect(this.foo).to.be('bar');
          return v;
        }), obj);
      });
      return it('should pass 3 parameters to the callback test: current value, index, the list', function() {
        var ls;
        ls = TypedList('String', ['foo']);
        return ls.map(function(val, index, list) {
          expect(val).to.be('foo');
          expect(index).to.be(0);
          expect(list).to.be(ls);
          return val;
        });
      });
    });
  });

}).call(this);
