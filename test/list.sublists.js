// Generated by CoffeeScript 1.3.1
(function() {
  var List, TypedList, expect, _ref;

  expect = require('expect.js');

  _ref = require('../lib/coll'), TypedList = _ref.TypedList, List = _ref.List;

  describe('TypedList / List Sub-List Methods', function() {
    describe('#take', function() {
      var l1, l2;
      l1 = l2 = null;
      beforeEach(function() {
        l1 = TypedList('String', 'hello world');
        return l2 = List([1, 2, 3, 4, 5]);
      });
      it('should return a new list of the first `howMany` items', function() {
        var x;
        x = l1.take(6);
        expect(x.join('')).to.be('hello ');
        expect(x).to.be.a(TypedList);
        x = l2.take(2);
        expect(x.length).to.be(2);
        expect(x[0]).to.be(1);
        expect(x[1]).to.be(2);
        return expect(x).to.be.a(List);
      });
      it('should return a copy of the entire list if `howMany` is greater than\nor equal to the length of the list', function() {
        var x;
        x = l1.take(99);
        expect(x.join('')).to.be('hello world');
        x = l1.take(11);
        return expect(x.join('')).to.be('hello world');
      });
      it('should return an empty list if `howMany` is less than or equal to zero', function() {
        var x;
        x = l1.take(-1);
        expect(x.length).to.be(0);
        x = l2.take(0);
        return expect(x.length).to.be(0);
      });
      it('should throw a `TypeError` if `howMany` is not passed', function() {
        return expect(function() {
          return l1.take();
        }).to.throwError(function(e) {
          return expect(e).to.be.a(TypeError);
        });
      });
      it('should throw a `TypeError` if `howMany` is not a number', function() {
        return expect(function() {
          return l1.take('foo');
        }).to.throwError(function(e) {
          return expect(e).to.be.a(TypeError);
        });
      });
      return it('should not mutate the instance list', function() {
        var x;
        x = l1.take(3);
        return expect(l1.join('')).to.be('hello world');
      });
    });
    describe('#takeWhile', function() {
      var l1, l2;
      l1 = l2 = null;
      beforeEach(function() {
        l1 = TypedList('String', 'hello world');
        return l2 = List([1, 2, 3, 4, 5]);
      });
      it('should return a new list of contiguous items from the beginning\nof the list until the iterator function returns false', function() {
        var x;
        x = l1.takeWhile(function(val) {
          return val !== ' ';
        });
        expect(x.join('')).to.be('hello');
        expect(x).to.be.a(TypedList);
        x = l2.takeWhile(function(val) {
          return val < 4;
        });
        expect(x.length).to.be(3);
        expect(x[0]).to.be(1);
        expect(x[1]).to.be(2);
        expect(x[2]).to.be(3);
        return expect(x).to.be.a(List);
      });
      it('should return an empty list if the first item does not pass\nthe iterator test', function() {
        var x;
        x = l2.takeWhile(function(val) {
          return val < 0;
        });
        return expect(x.length).to.be(0);
      });
      it('should pass 3 values to the iterator function:\ncurrent value, index, the list', function() {
        var i;
        i = 0;
        return l1.takeWhile(function() {
          expect(arguments.length).to.be(3);
          expect(arguments[0]).to.be(l1[i]);
          expect(arguments[1]).to.be(i);
          expect(arguments[2]).to.be(l1);
          return false;
        });
      });
      it('should accept a context object for the callback as an optional second parameter', function() {
        var obj;
        obj = {
          foo: 'bar'
        };
        return l1.takeWhile((function(v) {
          expect(this).to.be(obj);
          expect(this.foo).to.be('bar');
          return false;
        }), obj);
      });
      return it('should not mutate the instance list', function() {
        var x;
        x = l1.takeWhile(function(val) {
          return val !== ' ';
        });
        return expect(l1.join('')).to.be('hello world');
      });
    });
    describe('#drop', function() {
      var l1, l2;
      l1 = l2 = null;
      beforeEach(function() {
        l1 = TypedList('String', 'hello world');
        return l2 = List([1, 2, 3, 4, 5]);
      });
      it('should return a new list, dropping the first `howMany` items\nfrom the instance list', function() {
        var x;
        x = l1.drop(5);
        expect(x.join('')).to.be(' world');
        expect(x).to.be.a(TypedList);
        x = l2.drop(3);
        expect(x.length).to.be(2);
        expect(x[0]).to.be(4);
        expect(x[1]).to.be(5);
        return expect(x).to.be.a(List);
      });
      it('should return a copy of the entire list if `howMany` is less than\nor equal to zero', function() {
        var x;
        x = l1.drop(0);
        expect(x.join('')).to.be('hello world');
        x = l1.drop(-1);
        return expect(x.join('')).to.be('hello world');
      });
      it('should return an empty list if `howMany` is greater than or equal\nto the length of the list', function() {
        var x;
        x = l1.drop(11);
        expect(x.length).to.be(0);
        x = l2.drop(99);
        return expect(x.length).to.be(0);
      });
      it('should throw a `TypeError` if `howMany` is not passed', function() {
        return expect(function() {
          return l1.drop();
        }).to.throwError(function(e) {
          return expect(e).to.be.a(TypeError);
        });
      });
      it('should throw a `TypeError` if `howMany` is not a number', function() {
        return expect(function() {
          return l1.drop('foo');
        }).to.throwError(function(e) {
          return expect(e).to.be.a(TypeError);
        });
      });
      return it('should not mutate the instance list', function() {
        var x;
        x = l1.drop(3);
        return expect(l1.join('')).to.be('hello world');
      });
    });
    describe('#dropWhile', function() {
      var l1, l2;
      l1 = l2 = null;
      beforeEach(function() {
        l1 = TypedList('String', 'hello world');
        return l2 = List([1, 2, 3, 4, 5]);
      });
      it('should return a new list, dropping the contiguous items from the\nbeginning of the list that pass the iterator test', function() {
        var x;
        x = l1.dropWhile(function(val) {
          return val !== ' ';
        });
        expect(x.join('')).to.be(' world');
        expect(x).to.be.a(TypedList);
        x = l2.dropWhile(function(val) {
          return val < 4;
        });
        expect(x.length).to.be(2);
        expect(x[0]).to.be(4);
        expect(x[1]).to.be(5);
        return expect(x).to.be.a(List);
      });
      it('should return a copy of the entire list if the first item does\nnot pass the iterator test', function() {
        var x;
        x = l2.dropWhile(function(val) {
          return val < 0;
        });
        return expect(x.length).to.be(5);
      });
      it('should pass 3 values to the iterator function:\ncurrent value, index, the list', function() {
        var i;
        i = 0;
        return l1.dropWhile(function() {
          expect(arguments.length).to.be(3);
          expect(arguments[0]).to.be(l1[i]);
          expect(arguments[1]).to.be(i);
          expect(arguments[2]).to.be(l1);
          return false;
        });
      });
      it('should accept a context object for the callback as an optional second parameter', function() {
        var obj;
        obj = {
          foo: 'bar'
        };
        return l1.dropWhile((function(v) {
          expect(this).to.be(obj);
          expect(this.foo).to.be('bar');
          return false;
        }), obj);
      });
      return it('should not mutate the instance list', function() {
        var x;
        x = l1.dropWhile(function(val) {
          return val !== ' ';
        });
        return expect(l1.join('')).to.be('hello world');
      });
    });
    return describe('#group', function() {
      var l1, l2;
      l1 = l2 = null;
      beforeEach(function() {
        l1 = List([1, 2, 1, 3, 2, 6]);
        return l2 = TypedList('String', ['#fff', '#3366ee', 'magenta', '#ccc', 'red']);
      });
      it('should return a hash of lists; each list is composed of matching\nitems within the instance list and keys are representative\nof those items', function() {
        var x;
        x = l1.group();
        expect(x).to.only.have.keys('1', '2', '3', '6');
        expect(x['1']).to.be.a(List);
        expect(x['2']).to.be.a(List);
        expect(x['3']).to.be.a(List);
        expect(x['6']).to.be.a(List);
        expect(x['1'].length).to.be(2);
        expect(x['1'].every(function(v) {
          return v === 1;
        })).to.be(true);
        expect(x['2'].length).to.be(2);
        expect(x['2'].every(function(v) {
          return v === 2;
        })).to.be(true);
        expect(x['3'].length).to.be(1);
        expect(x['3'].every(function(v) {
          return v === 3;
        })).to.be(true);
        expect(x['6'].length).to.be(1);
        return expect(x['6'].every(function(v) {
          return v === 6;
        })).to.be(true);
      });
      it('should use the optional iterator function parameter to\ndetermine the groups', function() {
        var regex, x;
        regex = /^#[abcdef0-9]{3,6}$/i;
        x = l2.group(function(val) {
          if (regex.test(val)) {
            return 'hex';
          } else {
            return 'named';
          }
        });
        expect(x).to.only.have.keys('hex', 'named');
        expect(x['hex']).to.be.a(TypedList);
        expect(x['named']).to.be.a(TypedList);
        expect(x['hex'].length).to.be(3);
        expect(x['named'].length).to.be(2);
        expect(x['hex']).to.contain('#fff');
        expect(x['hex']).to.contain('#3366ee');
        expect(x['hex']).to.contain('#ccc');
        expect(x['named']).to.contain('magenta');
        return expect(x['named']).to.contain('red');
      });
      it('should pass 3 values to the iterator function:\ncurrent value, index, the list', function() {
        var i;
        i = 0;
        return l1.group(function() {
          expect(arguments.length).to.be(3);
          expect(arguments[0]).to.be(l1[i]);
          expect(arguments[1]).to.be(i);
          expect(arguments[2]).to.be(l1);
          ++i;
          return 'foo';
        });
      });
      return it('should accept a context object for the callback as an\
      optional second parameter', function() {
        var obj;
        obj = {
          foo: 'bar'
        };
        return l1.group((function(v) {
          expect(this).to.be(obj);
          expect(this.foo).to.be('bar');
          return v;
        }), obj);
      });
    });
  });

}).call(this);
