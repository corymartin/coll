// Generated by CoffeeScript 1.3.3
var List, expect;

expect = require('expect.js');

List = require('../lib/coll').List;

describe('List Accessor Methods', function() {
  describe('#slice', function() {
    var l1;
    l1 = null;
    beforeEach(function() {
      return l1 = List(['a', 'b', 'c', 'd']);
    });
    it('should return a new copy of the list if\nno parameters are passed', function() {
      var lsNew;
      lsNew = l1.slice();
      expect(lsNew.length).to.be(4);
      return expect(lsNew).not.to.be(l1);
    });
    it('should return a list of items from the specifed index\nto the specified end index', function() {
      var lsNew;
      lsNew = l1.slice(1, 3);
      expect(lsNew.length).to.be(2);
      expect(lsNew[0]).to.be('b');
      return expect(lsNew[1]).to.be('c');
    });
    it('should return a list of items from the specifed index\nto the end if no second parameter', function() {
      var lsNew;
      lsNew = l1.slice(1);
      expect(lsNew.length).to.be(3);
      expect(lsNew[0]).to.be('b');
      expect(lsNew[1]).to.be('c');
      return expect(lsNew[2]).to.be('d');
    });
    it('should return a specified number of items from the end of the list\nif only a negative is passed', function() {
      var lsNew;
      lsNew = l1.slice(-3);
      expect(lsNew.length).to.be(3);
      expect(lsNew[0]).to.be('b');
      expect(lsNew[1]).to.be('c');
      return expect(lsNew[2]).to.be('d');
    });
    it('should use the second parameter as an index from the end of the\nlist if it is negative', function() {
      var lsNew;
      lsNew = l1.slice(1, -1);
      expect(lsNew.length).to.be(2);
      expect(lsNew[0]).to.be('b');
      return expect(lsNew[1]).to.be('c');
    });
    it('should not modify the list instance it is being called upon', function() {
      var lsNew1, lsNew2, lsNew3;
      lsNew1 = l1.slice();
      lsNew2 = l1.slice(2);
      lsNew3 = l1.slice(2, 3);
      expect(l1 instanceof List).to.be(true);
      expect(l1.length).to.be(4);
      expect(l1[0]).to.be('a');
      expect(l1[1]).to.be('b');
      expect(l1[2]).to.be('c');
      return expect(l1[3]).to.be('d');
    });
    return it('should return a List instance', function() {
      var lsNew, lsNew2, lsNew3;
      lsNew = l1.slice();
      expect(lsNew instanceof List).to.be(true);
      lsNew2 = l1.slice(2);
      expect(lsNew2 instanceof List).to.be(true);
      lsNew3 = l1.slice(2, 1);
      return expect(lsNew3 instanceof List).to.be(true);
    });
  });
  describe('#concat', function() {
    var l1, l2;
    l1 = l2 = null;
    beforeEach(function() {
      l1 = List([1, 2]);
      return l2 = l1.concat(List([3]), List([4, 5]));
    });
    it('should merge a list with one or more other iterables', function() {
      var ls, x;
      expect(l2.length).to.be(5);
      expect(l2[0]).to.be(1);
      expect(l2[1]).to.be(2);
      expect(l2[2]).to.be(3);
      expect(l2[3]).to.be(4);
      expect(l2[4]).to.be(5);
      x = l1.concat([3, 4]);
      expect(x.length).to.be(4);
      ls = List('ab');
      x = ls.concat('cd');
      expect(x.length).to.be(4);
      expect(x[0]).to.be('a');
      expect(x[1]).to.be('b');
      expect(x[2]).to.be('c');
      return expect(x[3]).to.be('d');
    });
    it('should return a new list of the merged values', function() {
      expect(l1).not.to.be(l2);
      return expect(l2 instanceof List).to.be(true);
    });
    it('should work on a list of lists', function() {
      var l, lsa, lsb, lsc, _i, _len;
      lsa = List([List(['a', 'b']), List([3, 4])]);
      lsb = List([List([new Date])]);
      lsc = lsa.concat(lsb);
      expect(lsc.length).to.be(3);
      for (_i = 0, _len = lsc.length; _i < _len; _i++) {
        l = lsc[_i];
        expect(l instanceof List).to.be(true);
      }
      expect(lsc[0].length).to.be(2);
      expect(lsc[0]).to.be.a(List);
      expect(lsc[1].length).to.be(2);
      expect(lsc[1]).to.be.a(List);
      expect(lsc[2].length).to.be(1);
      return expect(lsc[2]).to.be.a(List);
    });
    return it('should not modify the instance list', function() {
      var x;
      x = l1.concat(List([3, 4]));
      expect(l1).to.be.a(List);
      return expect(l1.length).to.be(2);
    });
  });
  describe('#count', function() {
    var ls;
    ls = null;
    beforeEach(function() {
      return ls = List('aabaaba');
    });
    it('should return the number of occurences of the passed item', function() {
      var x;
      x = ls.count('b');
      expect(x).to.be(2);
      x = ls.count('a');
      expect(x).to.be(5);
      x = ls.count('z');
      return expect(x).to.be(0);
    });
    return it('should return the length of the list if not item is passed', function() {
      var x;
      x = ls.count();
      return expect(x).to.be(7);
    });
  });
  describe('#countIf', function() {
    var ls;
    ls = null;
    beforeEach(function() {
      return ls = List([2, 4, 5, 8, 10, 11, 14]);
    });
    it('should return the number of occurences that the iterator succeeds', function() {
      var x;
      x = ls.countIf(function(val) {
        return val % 2 !== 0;
      });
      expect(x).to.be(2);
      x = ls.countIf(function(val) {
        return val % 2 === 0;
      });
      return expect(x).to.be(5);
    });
    it('should accept a context object for the callback as an\
      optional second parameter', function() {
      var obj;
      ls = List('a');
      obj = {
        foo: 'bar'
      };
      return ls.countIf(obj, function(v) {
        expect(this).to.be(obj);
        expect(this.foo).to.be('bar');
        return true;
      });
    });
    return it('should pass 3 parameters to the callback test:\
      current value, index, the list', function() {
      ls = List(['foo']);
      return ls.countIf(function(val, index, list) {
        expect(val).to.be('foo');
        expect(index).to.be(0);
        return expect(list).to.be(ls);
      });
    });
  });
  describe('#contains', function() {
    var ls;
    ls = null;
    beforeEach(function() {
      return ls = List('aaba');
    });
    it('should return true if the passed item is in the list', function() {
      var result;
      result = ls.contains('b');
      return expect(result).to.be(true);
    });
    return it('should return false if the passed item is not in the list', function() {
      var result;
      result = ls.contains('z');
      return expect(result).to.be(false);
    });
  });
  describe('#clone', function() {
    return it('should return a new list with identical contents', function() {
      var copy, ls;
      ls = List('asdf');
      copy = ls.clone();
      expect(copy.length).to.be(ls.length);
      expect(copy).not.to.be(ls);
      return expect(copy).to.eql(ls);
    });
  });
  describe('#clean', function() {
    return it('should return a copy of the list with any occurences of `undefined`,\n`null`, and `NaN` removed', function() {
      var ls, x;
      ls = List(['a', null, 0, false, void 0, +'foo', 'bar']);
      x = ls.clean();
      expect(x).to.be.a(List);
      expect(x.length).to.be(4);
      expect(x[0]).to.be('a');
      expect(x[1]).to.be(0);
      expect(x[2]).to.be(false);
      return expect(x[3]).to.be('bar');
    });
  });
  describe('#toArray', function() {
    var ls;
    ls = null;
    beforeEach(function() {
      return ls = List('asd');
    });
    it('should return an array of the list\'s contents', function() {
      var arr;
      arr = ls.toArray();
      expect(arr).to.be.an(Array);
      expect(arr[0]).to.be('a');
      expect(arr[1]).to.be('s');
      return expect(arr[2]).to.be('d');
    });
    return it('should not modify the instance list', function() {
      ls.toArray();
      expect(ls).to.be.a(List);
      return expect(ls.length).to.be(3);
    });
  });
  describe('#get', function() {
    it('should get the item from the list at the specifed index', function() {
      var ls;
      ls = List('asd');
      return expect(ls.get(1)).to.be('s');
    });
    return it('should throw a `RangeError` if the index is not in the list', function() {
      var ls;
      ls = List('abc');
      expect(function() {
        return ls.get(99);
      }).to.throwError(function(e) {
        return expect(e).to.be.a(RangeError);
      });
      return expect(function() {
        return ls.get(-99);
      }).to.throwError(function(e) {
        return expect(e).to.be.a(RangeError);
      });
    });
  });
  describe('#first', function() {
    var l1, l2;
    l1 = l2 = null;
    beforeEach(function() {
      l1 = List('abcd');
      return l2 = List();
    });
    it('should return the first item from the list', function() {
      var x;
      x = l1.first();
      return expect(x).to.be('a');
    });
    it('should return `undefined` if the list is empty', function() {
      var x;
      x = l2.first();
      return expect(x).to.be(void 0);
    });
    return it('should accept a default value to be returned if the list is empty', function() {
      var x;
      x = l2.first('foo');
      return expect(x).to.be('foo');
    });
  });
  describe('#last', function() {
    var l1, l2;
    l1 = l2 = null;
    beforeEach(function() {
      l1 = List('abcd');
      return l2 = List();
    });
    it('should return the last item from the list', function() {
      var x;
      x = l1.last();
      return expect(x).to.be('d');
    });
    it('should return `undefined` if the list is empty', function() {
      var x;
      x = l2.last();
      return expect(x).to.be(void 0);
    });
    return it('should accept a default value to be returned if the list is empty', function() {
      var x;
      x = l2.last('foo');
      return expect(x).to.be('foo');
    });
  });
  describe('#unique', function() {
    var l1, l2, l3, o1, o2;
    l1 = l2 = l3 = null;
    o1 = o2 = null;
    beforeEach(function() {
      o1 = {
        a: 'a',
        b: 'b'
      };
      o2 = {
        a: 1,
        b: 2
      };
      l1 = List('abacbcdd');
      l2 = List([1, 2, 4, 1, 3, 4, 3]);
      return l3 = List([o1, o2, o1, o2, o2]);
    });
    it('should return a new list of non-duplicate items', function() {
      var x;
      x = l1.unique();
      expect(x).to.be.a(List);
      expect(x.length).to.be(4);
      expect(x).to.contain('a');
      expect(x).to.contain('b');
      expect(x).to.contain('c');
      expect(x).to.contain('d');
      x = l2.unique();
      expect(x.length).to.be(4);
      expect(x).to.contain(1);
      expect(x).to.contain(2);
      expect(x).to.contain(3);
      expect(x).to.contain(4);
      x = l3.unique();
      expect(x.length).to.be(2);
      expect(x).to.contain(o1);
      return expect(x).to.contain(o2);
    });
    return it('should not modify the instance list', function() {
      l3.unique();
      expect(l3).to.be.a(List);
      return expect(l3.length).to.be(5);
    });
  });
  describe('#max', function() {
    var d1, d2, d3, d4, l1, l2, l3;
    l1 = l2 = l3 = null;
    d1 = new Date(2012, 5, 10, 12, 12, 12);
    d2 = new Date(2011, 2, 1, 11, 11, 11);
    d3 = new Date(2012, 5, 15, 12, 12, 12);
    d4 = new Date(2011, 2, 1, 18, 11, 11);
    beforeEach(function() {
      l1 = List([44, 33, 4, 12, 67, 33]);
      l2 = List([d1, d2, d3, d4]);
      return l3 = List(['zzzz', 'zzz', 'zzzzzz', 'zzzzz']);
    });
    it('should return the maximum value from the list\n(for ordered types)', function() {
      var x;
      x = l1.max();
      expect(x).to.be(67);
      x = l2.max();
      return expect(x).to.be(d3);
    });
    it('should use the value returned by the optional comparer function to\ndetermine the max value', function() {
      var x;
      x = l3.max(function(a, b) {
        return a.length - b.length;
      });
      return expect(x).to.be('zzzzzz');
    });
    return it('should use the optional comparer property name to determine the\nmax value of an object', function() {
      var ls, o1, o2, o3, o4, o5, x;
      o1 = {
        foo: 34,
        bar: 'erf'
      };
      o2 = {
        foo: 12,
        bar: 'xcv'
      };
      o3 = {
        foo: 45,
        bar: 'bhu'
      };
      o4 = {
        foo: 5,
        bar: 'mer'
      };
      o5 = {
        foo: 26,
        bar: 'aer'
      };
      ls = List([o1, o2, o3, o4, o5]);
      x = ls.max('foo');
      expect(x).to.be(o3);
      x = ls.max('bar');
      return expect(x).to.be(o2);
    });
  });
  describe('#min', function() {
    var d1, d2, d3, d4, l1, l2, l3;
    l1 = l2 = l3 = null;
    d1 = new Date(2012, 5, 10, 12, 12, 12);
    d2 = new Date(2011, 2, 1, 11, 11, 11);
    d3 = new Date(2012, 5, 15, 12, 12, 12);
    d4 = new Date(2011, 2, 1, 18, 11, 11);
    beforeEach(function() {
      l1 = List([44, 33, 4, 12, 67, 33]);
      l2 = List([d1, d2, d3, d4]);
      return l3 = List(['zzzz', 'zzz', 'zzzzzz', 'zzzzz']);
    });
    it('should return the minimum value from the list\n(for ordered types)', function() {
      var x;
      x = l1.min();
      expect(x).to.be(4);
      x = l2.min();
      return expect(x).to.be(d2);
    });
    it('should use the value returned by the optional comparer function to\ndetermine the min value', function() {
      var x;
      x = l3.min(function(a, b) {
        return a.length - b.length;
      });
      return expect(x).to.be('zzz');
    });
    return it('should use the optional comparer property name to determine the\nmax value of an object', function() {
      var ls, o1, o2, o3, o4, o5, x;
      o1 = {
        foo: 34,
        bar: 'erf'
      };
      o2 = {
        foo: 12,
        bar: 'xcv'
      };
      o3 = {
        foo: 45,
        bar: 'bhu'
      };
      o4 = {
        foo: 5,
        bar: 'mer'
      };
      o5 = {
        foo: 26,
        bar: 'aer'
      };
      ls = List([o1, o2, o3, o4, o5]);
      x = ls.min('foo');
      expect(x).to.be(o4);
      x = ls.min('bar');
      return expect(x).to.be(o5);
    });
  });
  describe('#intersect', function() {
    var l1, l2;
    l1 = l2 = null;
    beforeEach(function() {
      l1 = List('abcabcd');
      return l2 = List('zxczxaab');
    });
    it('should return a new list containing items found in both lists', function() {
      var x;
      x = l1.intersect(l2);
      expect(x).to.be.a(List);
      expect(x).not.to.be(l1);
      expect(x).not.to.be(l2);
      expect(x.length).to.be(3);
      return expect(x.toArray()).to.eql(['a', 'b', 'c']);
    });
    it('should not modify either the instance list or the passed list', function() {
      var x;
      x = l1.intersect(l2);
      expect(l1).to.be.a(List);
      expect(l2).to.be.a(List);
      expect(l1.toArray()).to.eql('abcabcd'.split(''));
      return expect(l2.toArray()).to.eql('zxczxaab'.split(''));
    });
    return it('should accept any iterable as a list parameter', function() {
      var x;
      x = l1.intersect(List('xybyxdxy'));
      expect(x).to.be.a(List);
      expect(x.length).to.be(2);
      expect(x.toArray()).to.eql(['b', 'd']);
      x = l2.intersect(['a', 'c', 'a', 'y']);
      expect(x).to.be.a(List);
      expect(x.length).to.be(2);
      expect(x.toArray()).to.eql(['c', 'a']);
      return (function() {
        x = l1.intersect(arguments);
        expect(x).to.be.a(List);
        expect(x.length).to.be(2);
        return expect(x.toArray()).to.eql(['a', 'c']);
      })('aaa', 23, 'c', 'dd', 'a', /foo/, true);
    });
  });
  describe('#union', function() {
    var l1, l2;
    l1 = l2 = null;
    beforeEach(function() {
      l1 = List('asdfaaf');
      return l2 = List('aszxddqff');
    });
    it('should return a new list of the combined unique values', function() {
      var x;
      x = l1.union(l2);
      expect(x).to.be.a(List);
      expect(x).not.to.be(l1);
      expect(x).not.to.be(l2);
      expect(x.length).to.be(7);
      return expect(x.toArray()).to.eql('asdfzxq'.split(''));
    });
    it('should not modify either the instance list or the passed list', function() {
      var x;
      x = l1.union(l2);
      expect(l1).to.be.a(List);
      expect(l2).to.be.a(List);
      expect(l1.toArray()).to.eql('asdfaaf'.split(''));
      return expect(l2.toArray()).to.eql('aszxddqff'.split(''));
    });
    return it('should accept any iterable as a list parameter', function() {
      var x;
      x = l1.union(List('aaxxssyydd'));
      expect(x).to.be.a(List);
      expect(x.toArray()).to.eql('asdfxy'.split(''));
      x = l1.union(['a', 'c', 'a', 'y']);
      expect(x).to.be.a(List);
      expect(x.toArray()).to.eql('asdfcy'.split(''));
      return (function() {
        x = l1.union(arguments);
        expect(x).to.be.a(List);
        return expect(x.toArray()).to.eql('asdfqw'.split(''));
      })('d', 's', 'q', 'a', 'w');
    });
  });
  return describe('#difference', function() {
    var l1, l2;
    l1 = l2 = null;
    beforeEach(function() {
      l1 = List('asdfabbbaf');
      return l2 = List('axcveden');
    });
    it('should return a new list of the instance\'s values that are not\npresent in the passed iterable', function() {
      var x;
      x = l1.difference(l2);
      expect(x).to.be.a(List);
      expect(x).not.to.be(l1);
      expect(x).not.to.be(l2);
      expect(x.length).to.be(3);
      return expect(x.toArray()).to.eql('sfb'.split(''));
    });
    it('should not modify either the instance list or the passed list', function() {
      var x;
      x = l1.difference(l2);
      expect(l1).to.be.a(List);
      expect(l2).to.be.a(List);
      expect(l1.toArray()).to.eql('asdfabbbaf'.split(''));
      return expect(l2.toArray()).to.eql('axcveden'.split(''));
    });
    return it('should accept any iterable as a list parameter', function() {
      var x;
      x = l1.difference(List('aaxxssyy'));
      expect(x).to.be.a(List);
      expect(x.toArray()).to.eql('dfb'.split(''));
      x = l1.difference(['a', 'c', 'a', 'y']);
      expect(x).to.be.a(List);
      expect(x.toArray()).to.eql('sdfb'.split(''));
      return (function() {
        x = l1.difference(arguments);
        expect(x).to.be.a(List);
        return expect(x.toArray()).to.eql(['f', 'b']);
      })('d', 's', 'q', 'a', 'w');
    });
  });
});
