// Generated by CoffeeScript 1.3.1
(function() {
  var List, TypedList, expect, _ref;

  expect = require('expect.js');

  _ref = require('../lib/coll'), TypedList = _ref.TypedList, List = _ref.List;

  describe('TypedList / List Accessor Methods', function() {
    describe('#slice', function() {
      var l1;
      l1 = null;
      beforeEach(function() {
        return l1 = TypedList('String', ['a', 'b', 'c', 'd']);
      });
      it('returns a new copy of the list if no parameters are passed', function() {
        var lsNew;
        lsNew = l1.slice();
        expect(lsNew.length).to.be(4);
        return expect(lsNew).not.to.be(l1);
      });
      it('returns a list of items from the specifed index to the specified end index', function() {
        var lsNew;
        lsNew = l1.slice(1, 3);
        expect(lsNew.length).to.be(2);
        expect(lsNew[0]).to.be('b');
        return expect(lsNew[1]).to.be('c');
      });
      it('returns a list of items from the specifed index to the end if no second parameter', function() {
        var lsNew;
        lsNew = l1.slice(1);
        expect(lsNew.length).to.be(3);
        expect(lsNew[0]).to.be('b');
        expect(lsNew[1]).to.be('c');
        return expect(lsNew[2]).to.be('d');
      });
      it('returns a specified number of items from the end of the list if only a negative is passed', function() {
        var lsNew;
        lsNew = l1.slice(-3);
        expect(lsNew.length).to.be(3);
        expect(lsNew[0]).to.be('b');
        expect(lsNew[1]).to.be('c');
        return expect(lsNew[2]).to.be('d');
      });
      it('can use the second parameters as an index from the end of the list if it is negative', function() {
        var lsNew;
        lsNew = l1.slice(1, -1);
        expect(lsNew.length).to.be(2);
        expect(lsNew[0]).to.be('b');
        return expect(lsNew[1]).to.be('c');
      });
      it('does not modify the list instance it is being called upon', function() {
        var lsNew1, lsNew2, lsNew3;
        lsNew1 = l1.slice();
        lsNew2 = l1.slice(2);
        lsNew3 = l1.slice(2, 3);
        expect(l1 instanceof TypedList).to.be(true);
        expect(l1.length).to.be(4);
        expect(l1[0]).to.be('a');
        expect(l1[1]).to.be('b');
        expect(l1[2]).to.be('c');
        return expect(l1[3]).to.be('d');
      });
      return it('returns a TypedList instance', function() {
        var lsNew, lsNew2, lsNew3;
        lsNew = l1.slice();
        expect(lsNew instanceof TypedList).to.be(true);
        lsNew2 = l1.slice(2);
        expect(lsNew2 instanceof TypedList).to.be(true);
        lsNew3 = l1.slice(2, 1);
        return expect(lsNew3 instanceof TypedList).to.be(true);
      });
    });
    describe('#concat', function() {
      var l1, l2;
      l1 = l2 = null;
      beforeEach(function() {
        l1 = TypedList('Number', [1, 2]);
        return l2 = l1.concat(TypedList('Number', [3]), TypedList('Number', [4, 5]));
      });
      it('merges a list with one or more other iterables', function() {
        var ls, x;
        expect(l2.length).to.be(5);
        expect(l2[0]).to.be(1);
        expect(l2[1]).to.be(2);
        expect(l2[2]).to.be(3);
        expect(l2[3]).to.be(4);
        expect(l2[4]).to.be(5);
        x = l1.concat([3, 4]);
        expect(x.length).to.be(4);
        ls = TypedList('String', 'ab');
        x = ls.concat('cd');
        expect(x.length).to.be(4);
        expect(x[0]).to.be('a');
        expect(x[1]).to.be('b');
        expect(x[2]).to.be('c');
        return expect(x[3]).to.be('d');
      });
      it('returns a new list of the merged values', function() {
        expect(l1).not.to.be(l2);
        return expect(l2 instanceof TypedList).to.be(true);
      });
      it('works on a list of lists', function() {
        var l, lsa, lsb, lsc, _i, _len;
        lsa = TypedList(TypedList, [TypedList('String', ['a', 'b']), TypedList('Number', [3, 4])]);
        lsb = TypedList(TypedList, [TypedList('Date', [new Date])]);
        lsc = lsa.concat(lsb);
        expect(lsc.length).to.be(3);
        for (_i = 0, _len = lsc.length; _i < _len; _i++) {
          l = lsc[_i];
          expect(l instanceof TypedList).to.be(true);
        }
        expect(lsc[0].length).to.be(2);
        expect(lsc[0].type).to.be('String');
        expect(lsc[1].length).to.be(2);
        expect(lsc[1].type).to.be('Number');
        expect(lsc[2].length).to.be(1);
        return expect(lsc[2].type).to.be('Date');
      });
      return it('should not modify the instance list', function() {
        var x;
        x = l1.concat(TypedList('Number', [3, 4]));
        expect(l1).to.be.a(TypedList);
        return expect(l1.length).to.be(2);
      });
    });
    describe('#count', function() {
      var ls;
      ls = null;
      beforeEach(function() {
        return ls = TypedList('String', 'aabaaba');
      });
      it('should return the number of occurences of the passed item', function() {
        var x;
        x = ls.count('b');
        expect(x).to.be(2);
        x = ls.count('a');
        expect(x).to.be(5);
        x = ls.count('z');
        return expect(x).to.be(0);
      });
      return it('should return the length of the list if not item is passed', function() {
        var x;
        x = ls.count();
        return expect(x).to.be(7);
      });
    });
    describe('#countIf', function() {
      var ls;
      ls = null;
      beforeEach(function() {
        return ls = TypedList('Number', [2, 4, 5, 8, 10, 11, 14]);
      });
      it('should return the number of occurences that the iterator succeeds', function() {
        var x;
        x = ls.countIf(function(val) {
          return val % 2 !== 0;
        });
        expect(x).to.be(2);
        x = ls.countIf(function(val) {
          return val % 2 === 0;
        });
        return expect(x).to.be(5);
      });
      it('should accept a context object for the callback as an optional second parameter', function() {
        var obj;
        ls = TypedList('String', 'a');
        obj = {
          foo: 'bar'
        };
        return ls.countIf((function(v) {
          expect(this).to.be(obj);
          expect(this.foo).to.be('bar');
          return true;
        }), obj);
      });
      return it('should pass 3 parameters to the callback test: current value, index, the list', function() {
        ls = TypedList('String', ['foo']);
        return ls.countIf(function(val, index, list) {
          expect(val).to.be('foo');
          expect(index).to.be(0);
          return expect(list).to.be(ls);
        });
      });
    });
    describe('#contains', function() {
      var ls;
      ls = null;
      beforeEach(function() {
        return ls = TypedList('String', 'aaba');
      });
      it('should return true if the passed item is in the list', function() {
        var result;
        result = ls.contains('b');
        return expect(result).to.be(true);
      });
      return it('should return false if the passed item is not in the list', function() {
        var result;
        result = ls.contains('z');
        return expect(result).to.be(false);
      });
    });
    describe('#clone', function() {
      return it('should return a new list with identical contents', function() {
        var copy, ls;
        ls = TypedList('String', 'asdf');
        copy = ls.clone();
        expect(copy.length).to.be(ls.length);
        expect(copy).not.to.be(ls);
        return expect(copy).to.eql(ls);
      });
    });
    describe('#toArray', function() {
      var ls;
      ls = null;
      beforeEach(function() {
        return ls = TypedList('String', 'asd');
      });
      it('should return an array of the list\'s contents', function() {
        var arr;
        arr = ls.toArray();
        expect(arr).to.be.an(Array);
        expect(arr[0]).to.be('a');
        expect(arr[1]).to.be('s');
        return expect(arr[2]).to.be('d');
      });
      return it('should not modify the instance list', function() {
        ls.toArray();
        expect(ls).to.be.a(TypedList);
        return expect(ls.length).to.be(3);
      });
    });
    describe('#get', function() {
      it('should get the item from the list at the specifed index', function() {
        var ls;
        ls = TypedList('String', 'asd');
        return expect(ls.get(1)).to.be('s');
      });
      it('should return undefined if the list is empty', function() {
        var ls;
        ls = TypedList('String');
        return expect(ls.get(0)).to.be(void 0);
      });
      return it('should return undefined if the index is out of range', function() {
        var ls;
        ls = TypedList('String', 'asd');
        expect(ls.get(99)).to.be(void 0);
        return expect(ls.get(-99)).to.be(void 0);
      });
    });
    describe('#first', function() {
      var l1, l2;
      l1 = l2 = null;
      beforeEach(function() {
        l1 = TypedList('String', 'abcd');
        return l2 = TypedList('String');
      });
      it('should return the first item from the list', function() {
        var x;
        x = l1.first();
        return expect(x).to.be('a');
      });
      it('should return `undefined` if the list is empty', function() {
        var x;
        x = l2.first();
        return expect(x).to.be(void 0);
      });
      it('should return a list of the first "howMany" items\nif the `howMany` param is passed', function() {
        var x;
        x = l1.first(2);
        expect(x).to.be.a(TypedList);
        expect(x.length).to.be(2);
        expect(x[0]).to.be('a');
        return expect(x[1]).to.be('b');
      });
      it('should return an empty list if `howMany` is passed and the list is empty', function() {
        var x;
        x = l2.first(2);
        expect(x).to.be.a(TypedList);
        return expect(x.length).to.be(0);
      });
      return it('should not modify the instance list', function() {
        l1.first();
        l1.first(2);
        expect(l1).to.be.a(TypedList);
        return expect(l1.length).to.be(4);
      });
    });
    describe('#last', function() {
      var l1, l2;
      l1 = l2 = null;
      beforeEach(function() {
        l1 = TypedList('String', 'abcd');
        return l2 = TypedList('String');
      });
      it('should return the last item from the list', function() {
        var x;
        x = l1.last();
        return expect(x).to.be('d');
      });
      it('should return `undefined` if the list is empty', function() {
        var x;
        x = l2.last();
        return expect(x).to.be(void 0);
      });
      it('should return a list of the last "howMany" items\nif the `howMany` param is passed', function() {
        var x;
        x = l1.last(2);
        expect(x).to.be.a(TypedList);
        expect(x.length).to.be(2);
        expect(x[0]).to.be('c');
        return expect(x[1]).to.be('d');
      });
      it('should return an empty list if `howMany` is passed\nand the list is empty', function() {
        var x;
        x = l2.last(2);
        expect(x).to.be.a(TypedList);
        return expect(x.length).to.be(0);
      });
      return it('should not modify the instance list', function() {
        l1.last();
        l1.last(2);
        expect(l1).to.be.a(TypedList);
        return expect(l1.length).to.be(4);
      });
    });
    describe('#unique', function() {
      var l1, l2, l3, o1, o2;
      l1 = l2 = l3 = null;
      o1 = o2 = null;
      beforeEach(function() {
        o1 = {
          a: 'a',
          b: 'b'
        };
        o2 = {
          a: 1,
          b: 2
        };
        l1 = TypedList('String', 'abacbcdd');
        l2 = TypedList('Number', [1, 2, 4, 1, 3, 4, 3]);
        return l3 = TypedList('Object', [o1, o2, o1, o2, o2]);
      });
      it('should return a new list of non-duplicate items', function() {
        var x;
        x = l1.unique();
        expect(x).to.be.a(TypedList);
        expect(x.length).to.be(4);
        expect(x).to.contain('a');
        expect(x).to.contain('b');
        expect(x).to.contain('c');
        expect(x).to.contain('d');
        x = l2.unique();
        expect(x.length).to.be(4);
        expect(x).to.contain(1);
        expect(x).to.contain(2);
        expect(x).to.contain(3);
        expect(x).to.contain(4);
        x = l3.unique();
        expect(x.length).to.be(2);
        expect(x).to.contain(o1);
        return expect(x).to.contain(o2);
      });
      return it('should not modify the instance list', function() {
        l3.unique();
        expect(l3).to.be.a(TypedList);
        return expect(l3.length).to.be(5);
      });
    });
    describe('#intersect', function() {
      var l1, l2;
      l1 = l2 = null;
      beforeEach(function() {
        l1 = TypedList('String', 'abcabcd');
        return l2 = TypedList('String', 'zxczxaab');
      });
      it('should return a new list containing items found in both lists', function() {
        var x;
        x = l1.intersect(l2);
        expect(x).to.be.a(TypedList);
        expect(x).not.to.be(l1);
        expect(x).not.to.be(l2);
        expect(x.length).to.be(3);
        expect(x).to.contain('a');
        expect(x).to.contain('b');
        return expect(x).to.contain('c');
      });
      return it('should not modify either the instance list or the passed list', function() {
        var x;
        x = l1.intersect(l2);
        expect(l1).to.be.a(TypedList);
        expect(l2).to.be.a(TypedList);
        expect(l1.length).to.be(7);
        return expect(l2.length).to.be(8);
      });
    });
    describe('#intersperse', function() {
      var l1, l2;
      l1 = l2 = null;
      beforeEach(function() {
        l1 = TypedList('Number', [1, 2, 3]);
        return l2 = List(['a', new Date, [1, 2], true]);
      });
      it('should return a new list with the passed item inserted between\nevery item in the original list', function() {
        var regex, x;
        x = l1.intersperse(0);
        expect(x).to.be.a(TypedList);
        expect(x.length).to.be(5);
        expect(x[0]).to.be(1);
        expect(x[1]).to.be(0);
        expect(x[2]).to.be(2);
        expect(x[3]).to.be(0);
        expect(x[4]).to.be(3);
        regex = /foo/;
        x = l2.intersperse(regex);
        expect(x).to.be.a(List);
        expect(x.length).to.be(7);
        expect(x[0]).to.be('a');
        expect(x[1]).to.be(regex);
        expect(x[2]).to.be.a(Date);
        expect(x[3]).to.be(regex);
        expect(x[4]).to.eql([1, 2]);
        expect(x[5]).to.be(regex);
        return expect(x[6]).to.be(true);
      });
      return it('should not modify the instance list', function() {
        l1.intersperse(0);
        l2.intersperse('-');
        expect(l1.length).to.be(3);
        return expect(l2.length).to.be(4);
      });
    });
    describe('#take', function() {
      var l1, l2;
      l1 = l2 = null;
      beforeEach(function() {
        l1 = TypedList('String', 'hello world');
        return l2 = List([1, 2, 3, 4, 5]);
      });
      it('should return a new list of the first `howMany` items', function() {
        var x;
        x = l1.take(6);
        expect(x.join('')).to.be('hello ');
        expect(x).to.be.a(TypedList);
        x = l2.take(2);
        expect(x.length).to.be(2);
        expect(x[0]).to.be(1);
        expect(x[1]).to.be(2);
        return expect(x).to.be.a(List);
      });
      it('should return a copy of the entire list if `howMany` is greater than\nor equal to the length of the list', function() {
        var x;
        x = l1.take(99);
        expect(x.join('')).to.be('hello world');
        x = l1.take(11);
        return expect(x.join('')).to.be('hello world');
      });
      it('should return an empty list if `howMany` is less than or equal to zero', function() {
        var x;
        x = l1.take(-1);
        expect(x.length).to.be(0);
        x = l2.take(0);
        return expect(x.length).to.be(0);
      });
      it('should throw a `TypeError` if `howMany` is not passed', function() {
        return expect(function() {
          return l1.take();
        }).to.throwError(function(e) {
          return expect(e).to.be.a(TypeError);
        });
      });
      it('should throw a `TypeError` if `howMany` is not a number', function() {
        return expect(function() {
          return l1.take('foo');
        }).to.throwError(function(e) {
          return expect(e).to.be.a(TypeError);
        });
      });
      return it('should not mutate the instance list', function() {
        var x;
        x = l1.take(3);
        return expect(l1.join('')).to.be('hello world');
      });
    });
    describe('#takeWhile', function() {
      var l1, l2;
      l1 = l2 = null;
      beforeEach(function() {
        l1 = TypedList('String', 'hello world');
        return l2 = List([1, 2, 3, 4, 5]);
      });
      it('should return a new list of contiguous items from the beginning\nof the list until the iterator function returns false', function() {
        var x;
        x = l1.takeWhile(function(val) {
          return val !== ' ';
        });
        expect(x.join('')).to.be('hello');
        expect(x).to.be.a(TypedList);
        x = l2.takeWhile(function(val) {
          return val < 4;
        });
        expect(x.length).to.be(3);
        expect(x[0]).to.be(1);
        expect(x[1]).to.be(2);
        expect(x[2]).to.be(3);
        return expect(x).to.be.a(List);
      });
      it('should return an empty list if the first item does not pass\nthe iterator test', function() {
        var x;
        x = l2.takeWhile(function(val) {
          return val < 0;
        });
        return expect(x.length).to.be(0);
      });
      it('should pass 3 values to the iterator function:\ncurrent value, index, the list', function() {
        var i;
        i = 0;
        return l1.takeWhile(function() {
          expect(arguments.length).to.be(3);
          expect(arguments[0]).to.be(l1[i]);
          expect(arguments[1]).to.be(i);
          expect(arguments[2]).to.be(l1);
          return false;
        });
      });
      return it('should not mutate the instance list', function() {
        var x;
        x = l1.takeWhile(function(val) {
          return val !== ' ';
        });
        return expect(l1.join('')).to.be('hello world');
      });
    });
    describe('#drop', function() {
      var l1, l2;
      l1 = l2 = null;
      beforeEach(function() {
        l1 = TypedList('String', 'hello world');
        return l2 = List([1, 2, 3, 4, 5]);
      });
      it('should return a new list, dropping the first `howMany` items\nfrom the instance list', function() {
        var x;
        x = l1.drop(5);
        expect(x.join('')).to.be(' world');
        expect(x).to.be.a(TypedList);
        x = l2.drop(3);
        expect(x.length).to.be(2);
        expect(x[0]).to.be(4);
        expect(x[1]).to.be(5);
        return expect(x).to.be.a(List);
      });
      it('should return a copy of the entire list if `howMany` is less than\nor equal to zero', function() {
        var x;
        x = l1.drop(0);
        expect(x.join('')).to.be('hello world');
        x = l1.drop(-1);
        return expect(x.join('')).to.be('hello world');
      });
      it('should return an empty list if `howMany` is greater than or equal\nto the length of the list', function() {
        var x;
        x = l1.drop(11);
        expect(x.length).to.be(0);
        x = l2.drop(99);
        return expect(x.length).to.be(0);
      });
      it('should throw a `TypeError` if `howMany` is not passed', function() {
        return expect(function() {
          return l1.drop();
        }).to.throwError(function(e) {
          return expect(e).to.be.a(TypeError);
        });
      });
      it('should throw a `TypeError` if `howMany` is not a number', function() {
        return expect(function() {
          return l1.drop('foo');
        }).to.throwError(function(e) {
          return expect(e).to.be.a(TypeError);
        });
      });
      return it('should not mutate the instance list', function() {
        var x;
        x = l1.drop(3);
        return expect(l1.join('')).to.be('hello world');
      });
    });
    return describe('#dropWhile', function() {
      var l1, l2;
      l1 = l2 = null;
      beforeEach(function() {
        l1 = TypedList('String', 'hello world');
        return l2 = List([1, 2, 3, 4, 5]);
      });
      it('should return a new list, dropping the contiguous items from the\nbeginning of the list that pass the iterator test', function() {
        var x;
        x = l1.dropWhile(function(val) {
          return val !== ' ';
        });
        expect(x.join('')).to.be(' world');
        expect(x).to.be.a(TypedList);
        x = l2.dropWhile(function(val) {
          return val < 4;
        });
        expect(x.length).to.be(2);
        expect(x[0]).to.be(4);
        expect(x[1]).to.be(5);
        return expect(x).to.be.a(List);
      });
      it('should return a copy of the entire list if the first item does\nnot pass the iterator test', function() {
        var x;
        x = l2.dropWhile(function(val) {
          return val < 0;
        });
        return expect(x.length).to.be(5);
      });
      it('should pass 3 values to the iterator function:\ncurrent value, index, the list', function() {
        var i;
        i = 0;
        return l1.dropWhile(function() {
          expect(arguments.length).to.be(3);
          expect(arguments[0]).to.be(l1[i]);
          expect(arguments[1]).to.be(i);
          expect(arguments[2]).to.be(l1);
          return false;
        });
      });
      return it('should not mutate the instance list', function() {
        var x;
        x = l1.dropWhile(function(val) {
          return val !== ' ';
        });
        return expect(l1.join('')).to.be('hello world');
      });
    });
  });

}).call(this);
