// Generated by CoffeeScript 1.3.1
(function() {
  var List, TypedList, expect, _ref;

  expect = require('expect.js');

  _ref = require('../lib/coll'), TypedList = _ref.TypedList, List = _ref.List;

  describe('TypedList / List Accessor Methods', function() {
    describe('#slice', function() {
      var l1;
      l1 = null;
      beforeEach(function() {
        return l1 = TypedList('String', ['a', 'b', 'c', 'd']);
      });
      it('returns a new copy of the list if no parameters are passed', function() {
        var lsNew;
        lsNew = l1.slice();
        expect(lsNew.length).to.be(4);
        return expect(lsNew).not.to.be(l1);
      });
      it('returns a list of items from the specifed index to the specified end index', function() {
        var lsNew;
        lsNew = l1.slice(1, 3);
        expect(lsNew.length).to.be(2);
        expect(lsNew[0]).to.be('b');
        return expect(lsNew[1]).to.be('c');
      });
      it('returns a list of items from the specifed index to the end if no second parameter', function() {
        var lsNew;
        lsNew = l1.slice(1);
        expect(lsNew.length).to.be(3);
        expect(lsNew[0]).to.be('b');
        expect(lsNew[1]).to.be('c');
        return expect(lsNew[2]).to.be('d');
      });
      it('returns a specified number of items from the end of the list if only a negative is passed', function() {
        var lsNew;
        lsNew = l1.slice(-3);
        expect(lsNew.length).to.be(3);
        expect(lsNew[0]).to.be('b');
        expect(lsNew[1]).to.be('c');
        return expect(lsNew[2]).to.be('d');
      });
      it('can use the second parameters as an index from the end of the list if it is negative', function() {
        var lsNew;
        lsNew = l1.slice(1, -1);
        expect(lsNew.length).to.be(2);
        expect(lsNew[0]).to.be('b');
        return expect(lsNew[1]).to.be('c');
      });
      it('does not modify the list instance it is being called upon', function() {
        var lsNew1, lsNew2, lsNew3;
        lsNew1 = l1.slice();
        lsNew2 = l1.slice(2);
        lsNew3 = l1.slice(2, 3);
        expect(l1 instanceof TypedList).to.be(true);
        expect(l1.length).to.be(4);
        expect(l1[0]).to.be('a');
        expect(l1[1]).to.be('b');
        expect(l1[2]).to.be('c');
        return expect(l1[3]).to.be('d');
      });
      return it('returns a TypedList instance', function() {
        var lsNew, lsNew2, lsNew3;
        lsNew = l1.slice();
        expect(lsNew instanceof TypedList).to.be(true);
        lsNew2 = l1.slice(2);
        expect(lsNew2 instanceof TypedList).to.be(true);
        lsNew3 = l1.slice(2, 1);
        return expect(lsNew3 instanceof TypedList).to.be(true);
      });
    });
    describe('#concat', function() {
      var l1, l2;
      l1 = l2 = null;
      beforeEach(function() {
        l1 = TypedList('Number', [1, 2]);
        return l2 = l1.concat(TypedList('Number', [3]), TypedList('Number', [4, 5]));
      });
      it('merges a list with one or more other iterables', function() {
        var ls, x;
        expect(l2.length).to.be(5);
        expect(l2[0]).to.be(1);
        expect(l2[1]).to.be(2);
        expect(l2[2]).to.be(3);
        expect(l2[3]).to.be(4);
        expect(l2[4]).to.be(5);
        x = l1.concat([3, 4]);
        expect(x.length).to.be(4);
        ls = TypedList('String', 'ab');
        x = ls.concat('cd');
        expect(x.length).to.be(4);
        expect(x[0]).to.be('a');
        expect(x[1]).to.be('b');
        expect(x[2]).to.be('c');
        return expect(x[3]).to.be('d');
      });
      it('returns a new list of the merged values', function() {
        expect(l1).not.to.be(l2);
        return expect(l2 instanceof TypedList).to.be(true);
      });
      it('works on a list of lists', function() {
        var l, lsa, lsb, lsc, _i, _len;
        lsa = TypedList(TypedList, [TypedList('String', ['a', 'b']), TypedList('Number', [3, 4])]);
        lsb = TypedList(TypedList, [TypedList('Date', [new Date])]);
        lsc = lsa.concat(lsb);
        expect(lsc.length).to.be(3);
        for (_i = 0, _len = lsc.length; _i < _len; _i++) {
          l = lsc[_i];
          expect(l instanceof TypedList).to.be(true);
        }
        expect(lsc[0].length).to.be(2);
        expect(lsc[0].type).to.be('String');
        expect(lsc[1].length).to.be(2);
        expect(lsc[1].type).to.be('Number');
        expect(lsc[2].length).to.be(1);
        return expect(lsc[2].type).to.be('Date');
      });
      return it('should not modify the instance list', function() {
        var x;
        x = l1.concat(TypedList('Number', [3, 4]));
        expect(l1).to.be.a(TypedList);
        return expect(l1.length).to.be(2);
      });
    });
    describe('#indexOf', function() {
      var ls;
      ls = null;
      beforeEach(function() {
        return ls = TypedList('String', ['a', 'a', 'b', 'a']);
      });
      it('should return the index of the first item matching the passed item', function() {
        var index;
        index = ls.indexOf('a');
        expect(index).to.be(0);
        index = ls.indexOf('b');
        return expect(index).to.be(2);
      });
      it('should accept a start index as an optional second parameter', function() {
        var index;
        index = ls.indexOf('a', 0);
        expect(index).to.be(0);
        index = ls.indexOf('a', 2);
        return expect(index).to.be(3);
      });
      it('should return -1 if the start index is >= to the list length', function() {
        var index;
        index = ls.indexOf('a', 4);
        expect(index).to.be(-1);
        index = ls.indexOf('a', 99);
        return expect(index).to.be(-1);
      });
      it('should use an offset from the end of the list if the start index is negative', function() {
        var index;
        index = ls.indexOf('a', -1);
        expect(index).to.be(3);
        index = ls.indexOf('a', -3);
        return expect(index).to.be(1);
      });
      it('should search the entire list if the calculated index is less than zero', function() {
        var index;
        index = ls.indexOf('a', -7);
        expect(index).to.be(0);
        index = ls.indexOf('b', -7);
        return expect(index).to.be(2);
      });
      return it('should return -1 if the item is not found', function() {
        var index;
        index = ls.indexOf('z');
        return expect(index).to.be(-1);
      });
    });
    describe('#lastIndexOf', function() {
      var ls;
      ls = null;
      beforeEach(function() {
        return ls = TypedList('String', ['a', 'a', 'b', 'a']);
      });
      it('should return the index of the last item in the list matching the passed item', function() {
        var index;
        index = ls.lastIndexOf('a');
        expect(index).to.be(3);
        index = ls.lastIndexOf('b');
        return expect(index).to.be(2);
      });
      it('should accept an index to search backwards from as an optional second parameter', function() {
        var index;
        index = ls.lastIndexOf('a', 2);
        expect(index).to.be(1);
        index = ls.lastIndexOf('a', 3);
        expect(index).to.be(3);
        index = ls.lastIndexOf('a', 0);
        return expect(index).to.be(0);
      });
      it('should search the entire list if the index is >= to the list length', function() {
        var index;
        index = ls.lastIndexOf('a', 4);
        expect(index).to.be(3);
        index = ls.lastIndexOf('a', 99);
        return expect(index).to.be(3);
      });
      it('should use an offset from the end of the list if the index is negative', function() {
        var index;
        index = ls.lastIndexOf('a', -1);
        expect(index).to.be(3);
        index = ls.lastIndexOf('a', -2);
        return expect(index).to.be(1);
      });
      it('should return -1 if the calculated index is less than zero', function() {
        var index;
        index = ls.lastIndexOf('a', -99);
        expect(index).to.be(-1);
        index = ls.lastIndexOf('b', -99);
        return expect(index).to.be(-1);
      });
      return it('should return -1 if the item is not found', function() {
        var index;
        index = ls.lastIndexOf('z');
        return expect(index).to.be(-1);
      });
    });
    describe('#indicesOf', function() {
      var ls;
      ls = null;
      beforeEach(function() {
        return ls = TypedList('String', 'aabab');
      });
      it('should return an array of all indexes matching the passed item', function() {
        var indexes;
        indexes = ls.indicesOf('a');
        expect(indexes).to.be.an(Array);
        expect(indexes.length).to.be(3);
        expect(indexes[0]).to.be(0);
        expect(indexes[1]).to.be(1);
        return expect(indexes[2]).to.be(3);
      });
      it('should accept a start index as an optional second parameter', function() {
        var indexes;
        indexes = ls.indicesOf('a', 0);
        expect(indexes.length).to.be(3);
        indexes = ls.indicesOf('a', 1);
        expect(indexes.length).to.be(2);
        indexes = ls.indicesOf('a', 2);
        return expect(indexes.length).to.be(1);
      });
      it('should return an empty array if the start index is >= to the list length', function() {
        var indexes;
        indexes = ls.indicesOf('a', 5);
        expect(indexes.length).to.be(0);
        indexes = ls.indicesOf('a', 99);
        return expect(indexes.length).to.be(0);
      });
      it('should use an offset from the end of the list if the index is negative', function() {
        var indexes;
        indexes = ls.indicesOf('a', -3);
        expect(indexes.length).to.be(1);
        indexes = ls.indicesOf('a', -4);
        return expect(indexes.length).to.be(2);
      });
      it('should search the entire list if the calculated index is less than zero', function() {
        var indexes;
        indexes = ls.indicesOf('a', -7);
        return expect(indexes.length).to.be(3);
      });
      return it('should return an empty array if no occurences of the item is found', function() {
        var indexes;
        indexes = ls.indicesOf('z');
        expect(indexes).to.be.an(Array);
        return expect(indexes.length).to.be(0);
      });
    });
    describe('#indexIf', function() {
      var ls;
      ls = null;
      beforeEach(function() {
        return ls = TypedList('Number', [1, 5, 9, 14, 17]);
      });
      it('should return the index of the first item passing the callback test', function() {
        var index;
        index = ls.indexIf(function(val) {
          return val % 2 === 0;
        });
        expect(index).to.be(3);
        index = ls.indexIf(function(val) {
          return val % 5 === 0;
        });
        return expect(index).to.be(1);
      });
      it('should throw an error if the callback is not passed', function() {
        expect(function() {
          return ls.indexIf();
        }).to.throwError();
        return expect(function() {
          return ls.indexIf('foo');
        }).to.throwError();
      });
      it('should accept a starting index as an optional second parameter', function() {
        var index;
        index = ls.indexIf((function(val) {
          return val % 2 === 0;
        }), 0);
        expect(index).to.be(3);
        index = ls.indexIf((function(val) {
          return val % 2 !== 0;
        }), 1);
        expect(index).to.be(1);
        index = ls.indexIf((function(val) {
          return val % 2 !== 0;
        }), 3);
        return expect(index).to.be(4);
      });
      it('should return -1 if the start index is >= to the list length', function() {
        var index;
        index = ls.indexIf((function(val) {
          return val === 17;
        }), 5);
        expect(index).to.be(-1);
        index = ls.indexIf((function(val) {
          return val === 17;
        }), 99);
        return expect(index).to.be(-1);
      });
      it('should use an offset from the end of the list if the start index is negative', function() {
        var index;
        index = ls.indexIf((function(val) {
          return val % 2 !== 0;
        }), -1);
        expect(index).to.be(4);
        index = ls.indexIf((function(val) {
          return val % 2 !== 0;
        }), -3);
        return expect(index).to.be(2);
      });
      it('should search the entire list if the calculated index is less than zero', function() {
        var index;
        index = ls.indexIf((function(val) {
          return val % 2 !== 0;
        }), -99);
        expect(index).to.be(0);
        index = ls.indexIf((function(val) {
          return val % 2 === 0;
        }), -99);
        return expect(index).to.be(3);
      });
      it('should accept a context object for the callback as an optional third parameter', function() {
        var index, obj;
        obj = {
          foo: 'bar'
        };
        return index = ls.indexIf((function(val) {
          expect(this).to.be(obj);
          expect(this.foo).to.be('bar');
          return false;
        }), 0, obj);
      });
      it('should return -1 if the item is not found', function() {
        var index;
        index = ls.indexIf(function(val) {
          return val === 999;
        });
        return expect(index).to.be(-1);
      });
      return it('should pass 3 parameters to the callback test: current value, index, the list', function() {
        ls = TypedList('String', ['foo']);
        return ls.indexIf(function(val, index, list) {
          expect(val).to.be('foo');
          expect(index).to.be(0);
          return expect(list).to.be(ls);
        });
      });
    });
    describe('#lastIndexIf', function() {
      var ls;
      ls = null;
      beforeEach(function() {
        return ls = TypedList('String', ['a', 'a', 'b', 'a']);
      });
      it('should return the index of the last item passing the callback test', function() {
        var index;
        index = ls.lastIndexIf(function(val) {
          return val === 'a';
        });
        expect(index).to.be(3);
        index = ls.lastIndexIf(function(val) {
          return val === 'b';
        });
        return expect(index).to.be(2);
      });
      it('should throw an error if the callback is not passed', function() {
        expect(function() {
          return ls.lastIndexIf();
        }).to.throwError();
        return expect(function() {
          return ls.lastIndexIf('foo');
        }).to.throwError();
      });
      it('should accept an index to search backwards from as an optional second parameter', function() {
        var index;
        index = ls.lastIndexIf((function(val) {
          return val === 'a';
        }), 2);
        expect(index).to.be(1);
        index = ls.lastIndexIf((function(val) {
          return val === 'a';
        }), 3);
        expect(index).to.be(3);
        index = ls.lastIndexIf((function(val) {
          return val === 'a';
        }), 0);
        return expect(index).to.be(0);
      });
      it('should search the entire list if the index is >= to the list length', function() {
        var index;
        index = ls.lastIndexIf((function(val) {
          return val === 'a';
        }), 4);
        expect(index).to.be(3);
        index = ls.lastIndexIf((function(val) {
          return val === 'a';
        }), 99);
        return expect(index).to.be(3);
      });
      it('should use an offset from the end of the list if the index is negative', function() {
        var index;
        index = ls.lastIndexIf((function(val) {
          return val === 'a';
        }), -1);
        expect(index).to.be(3);
        index = ls.lastIndexIf((function(val) {
          return val === 'a';
        }), -2);
        return expect(index).to.be(1);
      });
      it('should return -1 if the calculated index is less than zero', function() {
        var index;
        index = ls.lastIndexIf((function(val) {
          return val === 'a';
        }), -99);
        expect(index).to.be(-1);
        index = ls.lastIndexIf((function(val) {
          return val === 'b';
        }), -99);
        return expect(index).to.be(-1);
      });
      it('should accept a context object for the callback as an optional third parameter', function() {
        var index, obj;
        obj = {
          foo: 'bar'
        };
        return index = ls.lastIndexIf((function(val) {
          expect(this).to.be(obj);
          expect(this.foo).to.be('bar');
          return false;
        }), 0, obj);
      });
      it('should return -1 if the item is not found', function() {
        var index;
        index = ls.lastIndexIf(function(val) {
          return val === 'z';
        });
        return expect(index).to.be(-1);
      });
      return it('should pass 3 parameters to the callback test: current value, index, the list', function() {
        ls = TypedList('String', ['foo']);
        return ls.lastIndexIf(function(val, index, list) {
          expect(val).to.be('foo');
          expect(index).to.be(0);
          return expect(list).to.be(ls);
        });
      });
    });
    describe('#indicesIf', function() {
      var ls;
      ls = null;
      beforeEach(function() {
        return ls = TypedList('String', 'aabab');
      });
      it('should return an array of all indexes matching the passed item', function() {
        var indexes;
        indexes = ls.indicesIf(function(v) {
          return v === 'a';
        });
        expect(indexes).to.be.an(Array);
        expect(indexes.length).to.be(3);
        expect(indexes[0]).to.be(0);
        expect(indexes[1]).to.be(1);
        return expect(indexes[2]).to.be(3);
      });
      it('should accept a start index as an optional second parameter', function() {
        var indexes;
        indexes = ls.indicesIf((function(v) {
          return v === 'a';
        }), 0);
        expect(indexes.length).to.be(3);
        indexes = ls.indicesIf((function(v) {
          return v === 'a';
        }), 1);
        expect(indexes.length).to.be(2);
        indexes = ls.indicesIf((function(v) {
          return v === 'a';
        }), 2);
        return expect(indexes.length).to.be(1);
      });
      it('should return an empty array if the start index is >= to the list length', function() {
        var indexes;
        indexes = ls.indicesIf((function(v) {
          return v === 'a';
        }), 5);
        expect(indexes.length).to.be(0);
        indexes = ls.indicesIf((function(v) {
          return v === 'a';
        }), 99);
        return expect(indexes.length).to.be(0);
      });
      it('should use an offset from the end of the list if the index is negative', function() {
        var indexes;
        indexes = ls.indicesIf((function(v) {
          return v === 'a';
        }), -3);
        expect(indexes.length).to.be(1);
        indexes = ls.indicesIf((function(v) {
          return v === 'a';
        }), -4);
        return expect(indexes.length).to.be(2);
      });
      it('should search the entire list if the calculated index is less than zero', function() {
        var indexes;
        indexes = ls.indicesIf((function(v) {
          return v === 'a';
        }), -7);
        return expect(indexes.length).to.be(3);
      });
      it('should return an empty array if no occurences of the item is found', function() {
        var indexes;
        indexes = ls.indicesIf(function(v) {
          return v === 'z';
        });
        expect(indexes).to.be.an(Array);
        return expect(indexes.length).to.be(0);
      });
      it('should accept a context object for the callback as an optional third parameter', function() {
        var obj;
        ls = TypedList('String', 'a');
        obj = {
          foo: 'bar'
        };
        return ls.indicesIf((function(v) {
          expect(this).to.be(obj);
          expect(this.foo).to.be('bar');
          return true;
        }), 0, obj);
      });
      return it('should pass 3 parameters to the callback test: current value, index, the list', function() {
        ls = TypedList('String', ['foo']);
        return ls.indicesIf(function(val, index, list) {
          expect(val).to.be('foo');
          expect(index).to.be(0);
          return expect(list).to.be(ls);
        });
      });
    });
    describe('#count', function() {
      var ls;
      ls = null;
      beforeEach(function() {
        return ls = TypedList('String', 'aabaaba');
      });
      it('should return the number of occurences of the passed item', function() {
        var x;
        x = ls.count('b');
        expect(x).to.be(2);
        x = ls.count('a');
        expect(x).to.be(5);
        x = ls.count('z');
        return expect(x).to.be(0);
      });
      return it('should return the length of the list if not item is passed', function() {
        var x;
        x = ls.count();
        return expect(x).to.be(7);
      });
    });
    describe('#countIf', function() {
      var ls;
      ls = null;
      beforeEach(function() {
        return ls = TypedList('Number', [2, 4, 5, 8, 10, 11, 14]);
      });
      it('should return the number of occurences that the iterator succeeds', function() {
        var x;
        x = ls.countIf(function(val) {
          return val % 2 !== 0;
        });
        expect(x).to.be(2);
        x = ls.countIf(function(val) {
          return val % 2 === 0;
        });
        return expect(x).to.be(5);
      });
      it('should accept a context object for the callback as an optional second parameter', function() {
        var obj;
        ls = TypedList('String', 'a');
        obj = {
          foo: 'bar'
        };
        return ls.countIf((function(v) {
          expect(this).to.be(obj);
          expect(this.foo).to.be('bar');
          return true;
        }), obj);
      });
      return it('should pass 3 parameters to the callback test: current value, index, the list', function() {
        ls = TypedList('String', ['foo']);
        return ls.countIf(function(val, index, list) {
          expect(val).to.be('foo');
          expect(index).to.be(0);
          return expect(list).to.be(ls);
        });
      });
    });
    describe('#contains', function() {
      var ls;
      ls = null;
      beforeEach(function() {
        return ls = TypedList('String', 'aaba');
      });
      it('should return true if the passed item is in the list', function() {
        var result;
        result = ls.contains('b');
        return expect(result).to.be(true);
      });
      return it('should return false if the passed item is not in the list', function() {
        var result;
        result = ls.contains('z');
        return expect(result).to.be(false);
      });
    });
    describe('#clone', function() {
      return it('should return a new list with identical contents', function() {
        var copy, ls;
        ls = TypedList('String', 'asdf');
        copy = ls.clone();
        expect(copy.length).to.be(ls.length);
        expect(copy).not.to.be(ls);
        return expect(copy).to.eql(ls);
      });
    });
    describe('#toArray', function() {
      var ls;
      ls = null;
      beforeEach(function() {
        return ls = TypedList('String', 'asd');
      });
      it('should return an array of the list\'s contents', function() {
        var arr;
        arr = ls.toArray();
        expect(arr).to.be.an(Array);
        expect(arr[0]).to.be('a');
        expect(arr[1]).to.be('s');
        return expect(arr[2]).to.be('d');
      });
      return it('should not modify the instance list', function() {
        ls.toArray();
        expect(ls).to.be.a(TypedList);
        return expect(ls.length).to.be(3);
      });
    });
    describe('#get', function() {
      it('should get the item from the list at the specifed index', function() {
        var ls;
        ls = TypedList('String', 'asd');
        return expect(ls.get(1)).to.be('s');
      });
      it('should return undefined if the list is empty', function() {
        var ls;
        ls = TypedList('String');
        return expect(ls.get(0)).to.be(void 0);
      });
      return it('should return undefined if the index is out of range', function() {
        var ls;
        ls = TypedList('String', 'asd');
        expect(ls.get(99)).to.be(void 0);
        return expect(ls.get(-99)).to.be(void 0);
      });
    });
    describe('#first', function() {
      var l1, l2;
      l1 = l2 = null;
      beforeEach(function() {
        l1 = TypedList('String', 'abcd');
        return l2 = TypedList('String');
      });
      it('should return the first item from the list', function() {
        var x;
        x = l1.first();
        return expect(x).to.be('a');
      });
      it('should return `undefined` if the list is empty', function() {
        var x;
        x = l2.first();
        return expect(x).to.be(void 0);
      });
      it('should return a list of the first "howMany" items\nif the `howMany` param is passed', function() {
        var x;
        x = l1.first(2);
        expect(x).to.be.a(TypedList);
        expect(x.length).to.be(2);
        expect(x[0]).to.be('a');
        return expect(x[1]).to.be('b');
      });
      it('should return an empty list if `howMany` is passed and the list is empty', function() {
        var x;
        x = l2.first(2);
        expect(x).to.be.a(TypedList);
        return expect(x.length).to.be(0);
      });
      return it('should not modify the instance list', function() {
        l1.first();
        l1.first(2);
        expect(l1).to.be.a(TypedList);
        return expect(l1.length).to.be(4);
      });
    });
    describe('#last', function() {
      var l1, l2;
      l1 = l2 = null;
      beforeEach(function() {
        l1 = TypedList('String', 'abcd');
        return l2 = TypedList('String');
      });
      it('should return the last item from the list', function() {
        var x;
        x = l1.last();
        return expect(x).to.be('d');
      });
      it('should return `undefined` if the list is empty', function() {
        var x;
        x = l2.last();
        return expect(x).to.be(void 0);
      });
      it('should return a list of the last "howMany" items\nif the `howMany` param is passed', function() {
        var x;
        x = l1.last(2);
        expect(x).to.be.a(TypedList);
        expect(x.length).to.be(2);
        expect(x[0]).to.be('c');
        return expect(x[1]).to.be('d');
      });
      it('should return an empty list if `howMany` is passed\nand the list is empty', function() {
        var x;
        x = l2.last(2);
        expect(x).to.be.a(TypedList);
        return expect(x.length).to.be(0);
      });
      return it('should not modify the instance list', function() {
        l1.last();
        l1.last(2);
        expect(l1).to.be.a(TypedList);
        return expect(l1.length).to.be(4);
      });
    });
    return describe('#unique', function() {
      var l1, l2, l3, o1, o2;
      l1 = l2 = l3 = null;
      o1 = o2 = null;
      beforeEach(function() {
        o1 = {
          a: 'a',
          b: 'b'
        };
        o2 = {
          a: 1,
          b: 2
        };
        l1 = TypedList('String', 'abacbcdd');
        l2 = TypedList('Number', [1, 2, 4, 1, 3, 4, 3]);
        return l3 = TypedList('Object', [o1, o2, o1, o2, o2]);
      });
      it('should return a new list of non-duplicate items', function() {
        var x;
        x = l1.unique();
        expect(x).to.be.a(TypedList);
        expect(x.length).to.be(4);
        expect(x).to.contain('a');
        expect(x).to.contain('b');
        expect(x).to.contain('c');
        expect(x).to.contain('d');
        x = l2.unique();
        expect(x.length).to.be(4);
        expect(x).to.contain(1);
        expect(x).to.contain(2);
        expect(x).to.contain(3);
        expect(x).to.contain(4);
        x = l3.unique();
        expect(x.length).to.be(2);
        expect(x).to.contain(o1);
        return expect(x).to.contain(o2);
      });
      return it('should not modify the instance list', function() {
        l3.unique();
        expect(l3).to.be.a(TypedList);
        return expect(l3.length).to.be(5);
      });
    });
  });

}).call(this);
